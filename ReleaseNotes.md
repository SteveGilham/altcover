Q. Never mind the fluff -- how do I get started?

A. Start with the Quick Start guide : https://github.com/SteveGilham/altcover/wiki/QuickStart-Guide

# 7.0.xxx (Genbu series release 1)
* Remove obsolete APIs 
  * `DotNet.TestOptions` extensions without `AltCover` in the name,
  * The `AltCover_Fake.DotNet.Testing.AltCover.ToolType` union type
  * In `AltCover_Fake.DotNet.Testing.AltCover.Params` 
    * making the `ToolType` member a `Fake.DotNet.ToolType` 
    * removing the `FakeToolType` field (effectively, this and the above mean a rename/move of the `Fake` over the obsoleted `AltCover` type)
    * removing the `WithToolType` method (assign the value directly to the `ToolType` now)
* Rename the `AltCover_Fake` namespace to `AltCoverFake`, because it's simpler that way
* Merge `AltCover.Parameters.ICLIArg2` and `AltCover.Parameters.ICLIArg3` into `AltCover.Parameters.ICLIArg`
* Rename `AltCover.Cake.AltCoverSettings.Force` to `AltCover.Cake.AltCoverSettings.Control`
* Remove the deprecated `altcover.dotnet` package with the old-style DotNetCliToolReference Tool

# 6.8.761  (Fukurou series release 13)
* Final 6.x release, barring serious bug-fixes
* Deprecate the `dotnet-altcover` DotNetCliToolReference Tool, package `altcover.dotnet`, prior to removal in the v7.0.xxx release.  See https://github.com/dotnet/sdk/issues/3115 for context
* Move delivered code to all new-style projects, and all supporting projects except where the old style is explicitly required
* [BUGFIX] Accept the OpenCover format variant generated by `coverlet` for PowerShell and, FWIW, the Visualizer.
* [BUGFIX] Provide a suitable binary (a simple shim called `AltCover.NetCoreApp.dll`) in the API nupkg for `AltCover.Fake.Api.toolPath AltCover.Fake.Implementation.DotNetCore` to return -- and test that it works, just like the build already tested `AltCover.Fake.Api.toolPath AltCover.Fake.Implementation.Framework`
* Ignore constructors for `[<Sealed; AbstractClass>]` types in F# for the purposes of coverage
* [API] `AltCover.CoverageFormats.PostProcess` to take an existing OpenCover format document and fill in the derived quantities e.g. `<Summary>` elements, sequence point branch visits, etc.
* [API] `AltCover.CoverageFormats.FormatFromCoverlet` to patch up the most obvious parts missing from `coverlet`'s dialect of the OpenCover format e.g. start and end columns, npath complexity, etc. as well as all the `PostProcess` features. Also reified as the cmdlet `Format-FromCoverletOpenCover`

# 6.7.750  (Fukurou series release 12)
* [PowerShell] Improve the `ConvertTo-BarChart`  cmdlet following the Visualizer-focussed enhancements in the previous release
* [PowerShell] Add `-WhatIf` capability to `Invoke-AltCover` for prepare and collect operations (syntax permitted, but meaningless for `-Version`)
* [PowerShell] Make the `Invoke-AltCover -ShowStatic` parameter take a typesafe enum (as well as untyped strings); a backwards compatible API extension.
* [Visualizer] new `--schemadir[=path]` command-line parameter to set or clear an application-level `GSETTINGS_SCHEMA_DIR` value
* [API] `PrepareParams.WhatIf : unit -> FSApi.ValidatedCommandLine`; and `CollectParams.WhatIf : bool -> FSApi.ValidatedCommandLine` to do read-only parameter validation and command line composition
* [API] The equivalent `public FSApi.ValidatedCommandLine PrepareArgs.WhatIf()` and `public FSApi.ValidatedCommandLine CollectArgs.WhatIf(bool afterPreparation)` for the CSApi types

# 6.6.747  (Fukurou series release 11)
* [API, Fake Helper API] Deprecate the `DotNet.TestOptions.WithImportModule` and `.WithGetVersion` extension methods in favour of the otherwise identical `DotNet.TestOptions.WithAltCoverImportModule` and `.WithAltCoverGetVersion`; the obsolete name now just calls through to the preferred one.
* [API] `--showstatic[:[-|+|++]]` (string `ShowStatic` default "-" in API, `-ShowStatic string` PowerShell) to reveal the code usually auto-filtered (e.g. auto-properties, some system generated types, structure comparison methods in F#...); either with coverage value `-3` (option '+') which is highlighted in the Visualizer but treated as 0 by [ReportGenerator](https://danielpalme.github.io/ReportGenerator/), or the value '0' (option '++')
* [API] `--showGenerated` (bool `ShowGenerated` default false in API, `-ShowGenerated` PowerShell) to reveal the code marked by [CompilerGenerated] or [GeneratedCode] with coverage value `-2`which is highlighted in the Visualizer but treated as 0 by [ReportGenerator](https://danielpalme.github.io/ReportGenerator/)
* [Visualizer, BUGFIX] fix the sorting of method by name for NCover format
* [Visualizer] group property `get_` and `set_`, and event `add_` and `remove_`,  methods together, under an appropriate icon
* [Visualizer] For F# modules containing only types, group the contents together under a module entry at class level, just as they would have been were the module to directly contain any functions
* [Visualizer] Types that only contain an `Invoke` method and constructors are shown with an approriate icon, too.
* [3rd Party] With the latest GTK#3 update, the GTK+ native libraries for win-x64 are no longer bundled into the nuget -- this seems to have been a transient behaviour in GtkSharp v3.22.25.49 only

# 6.5.739  (Fukurou series release 10)
* [Command-line and CLI tool] Rolling forwards with `runtimeconfig.template.json` -- it's not just for global tools : make all the executables .net core 3+ compatible.
  * this now packages the GTK# assemblies, and GTK+ native libraries for win-x64, for the .net core visualizer
  * also enable the build to execute on hosts with nothing before .net core 3 runtime
* [API, Fake Helper API] Deprecate the `DotNet.TestOptions.WithParameters` extension method in favour of the otherwise identical `DotNet.TestOptions.WithAltCoverParameters`; the obsolete name now just calls through to the preferred one.
* [Visualizer tool] Update GTK# for .net Core
* [BUGFIX] In `ConvertFrom-NCover`, don't add classes for which there is no method coverage data.  This mainly affects system generated classes implementation details, including ones actually called `<PrivateImplementationDetails$...>...`
* In cobertura format output, including the `ConvertTo-Cobertura` cmdlet, truncate rates to 2 decimal places (equivalent to integral percentages used elsewhere)

# 6.4.734 (Fukurou series release 9)
* [FAKE Helper API] Fake >= 5.18.1 is required for this release (the work-round for FAKE issue #2412 has been removed)
* [FAKE Helper API] Add this constraint as an explicit dependency
* [API] Add `Tool of String` a literal alongside `FilePath of String`, which is expanded to a full path to `TypeSafe.FilePath`
* [API] Add `IncludeItem of Regex` which represents a `?`-prefix regex string to `TypeSafe.FilterItem`
* Trap and log exceptions reported in Issue #71 as files `<coverage report path>.<timestamp>.exn`
* Other housekeeping

# 6.3.729 (Fukurou series release 8)
* Filter out assemblies without the `ILOnly` bit set (i.e. pretty much anything C++/CLI, even with the deprecated /clr:pure compiler flag set)
* [FAKE Helper API] Fake >= 5.18.0 is required for this release
* [FAKE Helper API] Deprecate `AltCover_Fake.DotNet.Testing.AltCover.ToolType` in favour of `Fake.DotNet.ToolType` in the `AltCover_Fake.DotNet.Testing.AltCover.Params` record structure.  
* [FAKE Helper API] Helper functions in `AltCover_Fake.DotNet.Testing.AltCover`
  * `splitCommandLine: string -> string list` for breaking up composed command lines e.g. from `Fake.DotNet.Testing.NUnit3.buildArgs` or `Fake.DotNet.Testing.XUnit2.buildArgs`
  * `buildDotNetTestCommandLine: (DotNet.TestOptions -> DotNet.TestOptions) -> string -> (string * string list)` taking the arguments for `DotNet.test` and returning the `dotnet` path and the rest of the command line
  * `runWithMono: string option -> Params -> 'a` to execute the `Params` using the path to the Mono executable if it's a FAKE-style full framework tool on Windows (equivalent to the deprecated `AltCover.ToolType.Mono`)
  * `Params.WithToolType: Fake.DotNet.ToolType -> Params` Setting the new tool type using this member is the preferred forward-compatible way to do this

# 6.2.727 (Fukurou series release 7 respin)
* [BUGFIX] Issue #74 -- Strip unwanted dependencies from released code.
* Generally, move to .net core 3.0 for build (many other changes in process only)
  * In .net core 3.0 release, `dotnet build` no longer does a `dotnet publish` to the output directory
  * With the F# 4.7 compiler, static linking FSharp.Core into the recorder has been fixed, and has been adopted
  * Issues #68 and #73 and their fixes are now moot; in particular, `FSharp.Core` no longer needs to be auto-excluded from instrumentation in the .net core tool any more than in the Framework tool; nor does that assembly need to be copied if otherwise absent.

# 6.2.719 (Fukurou series release 6)
* [BUGFIX] #Issue73 In .net core 3.0 preview and RC, `dotnet build` does a `dotnet publish` to the output directory, including FSharp.Core in F# projects.  Automatically exclude that file from instrumentation by the .net core tool to avoid mutually recursive calls between the recorder assembly and FSharp.Core that cause a stack overflow.  This  is not required for the Framework/Mono tool as that static links its dependency. I've not found a way to static-link FSharp.Core in the .net core world that doesn't fail with errors.
* [BUGFIX] For --visibleBranches, fix up C# loops, and the path numbering for decompiled `switch`/`match` logic

# 6.2.714 (Fukurou series release 5)
* [BUGFIX] Finish wiring up `/p:AltCoverLocalSource` support
* [BUGFIX] Fix failure when input/output directories were specified with a trailing separator character
* [HACK] mitigate Issue #71 by simply ignoring null module identifiers.
* [API] `-v|--visibleBranches` option (bool `VisibleBranches` default false in API, `-VisibleBranches` PowerShell flag) to simplify the reporting of `switch` or `match` cases where the compiler produces a tangle of `if`/`else` branches that give surprising results in a `ReportGenerator` output (e.g. `null` taking a different branch to a `default` case than a non-`null` value as per Issue 72)
* Use a leading `?` as a negator for filter matches e.g. `?(a|b)` means "exclude anything that doesn't match a or match b", or `?MyApp` means exclude anything that doesn't contain `MyApp`; no valid .net regex begins with this so it's backwards compatible.  Between this and the previous release's `--localSource` (now fully supported) option, the need to resort to cumbersome constructs involving negative lookahead regexes should be reduced.

# 6.1.708 (Fukurou series release 4)
* [BUGFIX] reinstate the PowerShell Core (`pwsh`) `Invoke-AltCover` support for strongnaming.
* [API] `-l|--localSource` option (bool `LocalSource` default false in API, `-LocalSource` PowerShell flag) to ignore .pdb files that refer to source files not present on the current computer (test is if the first file found exists or not, and assumes that this is all-or-nothing, and assume no coincidences in naming).
---
# 6.0.705 (Fukurou series release 3)
* [BUGFIX] in the case of multiple output folders, properly weave the AltCover recorder assembly dependency into all `dotnet` projects, not just the first.
* [BUGFIX] when using the `dotnet` version of the tools, and when a suitable FSharp.Core package is present in the nuget cache, it is not necessary to copy one from the AltCover deployment to the output folder for a `dotnet` project
* [BUGFIX] create the directory to hold the report file if it does not already exists
* Use Mono.Cecil 0.11 for strongnaming in `dotnet`, removing the local reimplementation of assembly writing with strongnaming.

# 6.0.700 (Fukurou series release 2)
* [BUGFIX] in `dotnet test` the pipe character `|` is used as a separator because the previous choice of `;` didn't play nice with MSBuild.  To escape pipe characters inside regular expressions, double them up `||`.  See the [Usage](https://github.com/SteveGilham/altcover/wiki/Usage) and [`dotnet test`](https://github.com/SteveGilham/altcover/wiki/%60dotnet-test%60-integration) wiki pages for more detail.

# 6.0.698 (Fukurou series release 1)
* [BREAKING] Allow multiple input and output directories for instrumentation into a single report.  This changes the types in API structures from `string` to `string seq` (F#) or `string[]` (C#) where appropriate.  Use case : [instrument multiple unit test assemblies in one go](https://github.com/SteveGilham/altcover/blob/9f6ed07e9d5d1c35d8c99a589fb77fe1868cecab/Build/targets.fsx#L702-L703) for running as [a single test step](https://github.com/SteveGilham/altcover/blob/9f6ed07e9d5d1c35d8c99a589fb77fe1868cecab/Build/targets.fsx#L724-L726) to collect coverage.
* Enable the `--sn` and `-k` arguments in the `dotnet` build.  This doesn't change any APIs, but it does mean that these arguments are no longer ignored for the .net core platform.  This work borrows from changes recently made in Mono.Cecil but not yet in a release build; in the fullness of time, my roll-my-own support will be replaced with the real deal.
* For what it's worth, enable the `-d` argument in the .net framework/Mono build (as the APIs already exposed this, the change is behavioural -- any values supplied are used rather than silently dropped)


For previous releases (5.x.x and earlier) [go here](https://github.com/SteveGilham/altcover/blob/master/ReleaseNotes%20-%20Previously.md)