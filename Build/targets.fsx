// Downloads/docker-machine-Windows-x86_64 create --driver virtualbox <name>

open System
open System.Diagnostics.Tracing
open System.IO
open System.Reflection
open System.Text
open System.Xml
open System.Xml.Linq
open System.Xml.Schema

open Actions
open AltCode.Fake.DotNet
open AltCoverFake.DotNet.DotNet
open AltCoverFake.DotNet.Testing

open Fake.Core
open Fake.Core.TargetOperators
open Fake.DotNet
open Fake.DotNet.NuGet.NuGet
open Fake.DotNet.Testing.NUnit3
open Fake.Testing
open Fake.DotNet.Testing
open Fake.IO
open Fake.IO.FileSystemOperators
open Fake.IO.Globbing
open Fake.IO.Globbing.Operators
open Fake.Tools.Git

open NUnit.Framework
open Swensen.Unquote

let Copyright = ref String.Empty
let Version = ref String.Empty

let lastGoodPackage () =
    let n =
        !! "./_Packaging/altcover.*.nupkg"
        |> Seq.map (fun p -> System.Version((Path.GetFileNameWithoutExtension p).Substring(9)))

    if n |> Seq.isEmpty |> not then
        let v = n |> Seq.max
        Version.Value <- v.ToString()
        printfn "Default version from packages = %A" v
    else
        let version = Actions.GetVersionFromYaml()
        let (result, _, _) = Actions.LocalVersion "none" version
        Version.Value <- result
        printfn "Default version from date = %A" result

lastGoodPackage ()

let consoleBefore =
    (Console.ForegroundColor, Console.BackgroundColor)

let AltCoverFilter (p: Primitive.PrepareOptions) =
    { p with
          MethodFilter =
              "WaitForExitCustom"
              :: (p.MethodFilter |> Seq.toList)
          AssemblyFilter =
              [ @"\.DataCollector"; "Sample" ]
              @ (p.AssemblyFilter |> Seq.toList)
          AttributeFilter =
              "TestSDKAutoGeneratedCode"
              :: (p.AttributeFilter |> Seq.toList)
          LocalSource = true
          TypeFilter =
              [ @"System\."
                @"Sample3\.Class2"
                "Microsoft"
                "ICSharpCode"
                "UnitTestStub" ]
              @ (p.TypeFilter |> Seq.toList) }

let AltCoverFilterTypeSafe (p: TypeSafe.PrepareOptions) =
    { p with
          MethodFilter =
              [ TypeSafe.Raw "WaitForExitCustom" ]
              |> p.MethodFilter.Join
          AssemblyFilter =
              [ @"\.DataCollector"; "Sample" ]
              |> Seq.map TypeSafe.Raw
              |> p.AssemblyFilter.Join
          LocalSource = TypeSafe.Set
          TypeFilter =
              [ @"System\."
                @"Sample3\.Class2"
                "Microsoft"
                "ICSharpCode"
                "UnitTestStub"
                "SolutionRoot" ]
              |> Seq.map TypeSafe.Raw
              |> p.TypeFilter.Join }

let AltCoverFilterX (p: Primitive.PrepareOptions) =
    { p with
          MethodFilter =
              "WaitForExitCustom"
              :: (p.MethodFilter |> Seq.toList)
          AssemblyFilter =
              [ @"\.DataCollector"; "Sample" ]
              @ (p.AssemblyFilter |> Seq.toList)
          LocalSource = true
          TypeFilter =
              [ @"System\."
                @"Sample3\.Class2"
                "Microsoft"
                "ICSharpCode"
                "<Start"
                "UnitTestStub" ]
              @ (p.TypeFilter |> Seq.toList) }

let AltCoverFilterXTypeSafe (p: TypeSafe.PrepareOptions) =
    { p with
          MethodFilter =
              [ TypeSafe.Raw "WaitForExitCustom" ]
              |> p.MethodFilter.Join
          AssemblyFilter =
              [ @"\.DataCollector"; "Sample" ]
              |> Seq.map TypeSafe.Raw
              |> p.AssemblyFilter.Join
          LocalSource = TypeSafe.Set
          TypeFilter =
              [ @"System\."
                @"Sample3\.Class2"
                "Microsoft"
                "ICSharpCode"
                "UnitTestStub"
                "SolutionRoot" ]
              |> Seq.map TypeSafe.Raw
              |> p.TypeFilter.Join }

let programFiles = Environment.environVar "ProgramFiles"

let programFiles86 =
    Environment.environVar "ProgramFiles(x86)"

let dotnetPath =
    "dotnet"
    |> Fake.Core.ProcessUtils.tryFindFileOnPath

let dotnetOptions (o: DotNet.Options) =
    match dotnetPath with
    | Some f -> { o with DotNetCliPath = f }
    | None -> o

let dotnetVersion =
    DotNet.getVersion (fun o -> o.WithCommon dotnetOptions)

printfn "Using dotnet version %s" dotnetVersion

let dotnetInfo =
    DotNet.exec (fun o -> dotnetOptions (o.WithRedirectOutput true)) "" "--info"

let MSBuildPath =
    dotnetInfo.Results
    |> Seq.filter (fun x -> x.IsError |> not)
    |> Seq.map (fun x -> x.Message)
    |> Seq.tryFind (fun x -> x.Contains "Base Path:")
    |> Option.map (fun x -> Path.Combine(x.Replace("Base Path:", "").TrimStart(), "MSBuild.dll"))

printfn "MSBuildPath = %A" MSBuildPath

let dotnetOptionsWithRollForwards (o: DotNet.Options) =
    let env =
        o.Environment.Add("DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX", "2")

    o.WithEnvironment env

let (fxcop, dixon) =
    if Environment.isWindows then
        let expect =
            "./packages/fxcop/FxCopCmd.exe"
            |> Path.getFullName

        if File.Exists expect then
            (Some expect,
             Some(
                 "./packages/fxcop/DixonCmd.exe"
                 |> Path.getFullName
             ))
        else
            (None, None)
    else
        (None, None)

let monoOnWindows =
    if Environment.isWindows then
        [ programFiles; programFiles86 ]
        |> List.filter (String.IsNullOrWhiteSpace >> not)
        |> List.map (fun s -> s @@ "Mono/bin/mono.exe")
        |> List.tryFind File.Exists
    else
        None

let dotnetPath86 =
    if Environment.isWindows then
        let perhaps =
            [ programFiles86 ]
            |> List.filter (String.IsNullOrWhiteSpace >> not)
            |> List.map (fun s -> s @@ "dotnet\dotnet.EXE")
            |> List.tryFind File.Exists

        match perhaps with
        | Some path ->
            try // detect if we have the SDK
                DotNet.info
                    (fun opt ->
                        { opt with
                              Common =
                                  { dotnetOptions opt.Common with
                                        DotNetCliPath = path } })
                |> ignore

                perhaps
            with
            | _ -> None
        | _ -> None
    else
        None

let dotnetOptions86 (o: DotNet.Options) =
    match dotnetPath86 with
    | Some f -> { o with DotNetCliPath = f }
    | None -> o

let nugetCache =
    Path.Combine(Environment.GetFolderPath Environment.SpecialFolder.UserProfile, ".nuget/packages")

let pwsh =
    match "pwsh" |> Fake.Core.ProcessUtils.tryFindFileOnPath with
    | Some path -> path
    | _ -> "pwsh"

let toolPackages =
    let xml =
        "./Build/NuGet.csproj"
        |> Path.getFullName
        |> XDocument.Load

    xml.Descendants(XName.Get("PackageReference"))
    |> Seq.filter (fun x -> x.Attribute(XName.Get("Include")) |> isNull |> not)
    |> Seq.filter
        (fun x ->
            match x.Attribute(XName.Get("Condition")) with
            | null -> true
            | a ->
                match (a.Value = "'$(OS)' == 'Windows_NT'", Environment.isWindows) with
                | (true, true)
                | (false, false) -> true
                | _ -> false)
    |> Seq.map (fun x -> (x.Attribute(XName.Get("Include")).Value, x.Attribute(XName.Get("version")).Value))
    |> Map.ofSeq

let packageVersion (p: string) =
    p.ToLowerInvariant() + "/" + (toolPackages.Item p)

// MCS packages.config
let openCoverConsole =
    ("./packages/"
     + (packageVersion "OpenCover")
     + "/tools/OpenCover.Console.exe")
    |> Path.getFullName

let nunitConsole =
    ("./packages/"
     + (packageVersion "NUnit.ConsoleRunner")
     + "/tools/nunit3-console.exe")
    |> Path.getFullName

let xmldoc2cmdletdoc =
    ("./packages/"
     + (packageVersion "XmlDoc2CmdletDoc")
     + "/tools/netcoreapp2.1/XmlDoc2CmdletDoc.dll")
    |> Path.getFullName

let coverletcollector =
    ("./packages/"
     + (packageVersion "coverlet.collector")
     + "/build/netstandard1.0/coverlet.collector.dll")
    |> Path.getFullName

let cliArguments =
    { MSBuild.CliArguments.Create() with
          ConsoleLogParameters = []
          DistributedLoggers = None
          Properties = []
          DisableInternalBinLog = true }

let cliTaggedArguments tag =
    { MSBuild.CliArguments.Create() with
          ConsoleLogParameters = []
          DistributedLoggers = None
          Properties = [ "AltCoverTag", (tag + "_") ]
          DisableInternalBinLog = true }

let withWorkingDirectoryVM dir o =
    { dotnetOptions o with
          WorkingDirectory = Path.getFullName dir
          Verbosity = Some DotNet.Verbosity.Minimal }

let withWorkingDirectoryVN dir o =
    { dotnetOptions o with
          WorkingDirectory = Path.getFullName dir
          Verbosity = Some DotNet.Verbosity.Normal }

let withWorkingDirectoryOnly dir o =
    { dotnetOptions o with
          WorkingDirectory = Path.getFullName dir }

let testWithCLIArguments (o: Fake.DotNet.DotNet.TestOptions) = { o with MSBuildParams = cliArguments }
let buildWithCLIArguments (o: Fake.DotNet.DotNet.BuildOptions) = { o with MSBuildParams = cliArguments }

let testWithCLITaggedArguments tag (o: Fake.DotNet.DotNet.TestOptions) =
    { o with
          MSBuildParams = cliTaggedArguments tag }

let buildWithCLITaggedArguments tag (o: Fake.DotNet.DotNet.BuildOptions) =
    { o with
          MSBuildParams = cliTaggedArguments tag }

let NuGetAltCover =
    toolPackages
    |> Seq.filter (fun kv -> kv.Key = "altcover")
    |> Seq.map
        (fun _ ->
            ("./packages/"
             + (packageVersion "altcover")
             + "/tools/net472/AltCover.exe")
            |> Path.getFullName)
    |> Seq.filter File.Exists
    |> Seq.tryHead

let ForceTrueOnly = DotNet.CLIOptions.Force true
let FailTrue = DotNet.CLIOptions.Fail true

let GreenSummary = DotNet.CLIOptions.Summary "Green"

let ForceTrue =
    DotNet.CLIOptions.Many [ ForceTrueOnly
                             GreenSummary ]

let ForceTrueFast =
    DotNet.CLIOptions.Many [ FailTrue
                             ForceTrueOnly
                             GreenSummary ]

let dotnetAltcover =
    Fake.DotNet.ToolType.CreateFrameworkDependentDeployment dotnetOptions

let dotnetAltcover86 =
    Fake.DotNet.ToolType.CreateFrameworkDependentDeployment dotnetOptions86

let frameworkAltcover =
    Fake.DotNet.ToolType.CreateFullFramework()

let defaultTestOptions fwk common (o: DotNet.TestOptions) =
    { o.WithCommon(
          (fun o2 ->
              { o2 with
                    Verbosity = Some DotNet.Verbosity.Normal })
          >> common
      ) with
          NoBuild = true
          Framework = fwk // Some "net6.0"
          Configuration = DotNet.BuildConfiguration.Debug }

let defaultDotNetTestCommandLine fwk project =
    AltCoverCommand.buildDotNetTestCommandLine (defaultTestOptions fwk dotnetOptions) project

let defaultDotNetTestCommandLine86 fwk project =
    AltCoverCommand.buildDotNetTestCommandLine (defaultTestOptions fwk dotnetOptions86) project

let coverletOptions (o: DotNet.Options) =
    { dotnetOptions o with
          CustomParams = Some "--collect:\"XPlat Code Coverage\"" }

let coverletTaggedTestOptions report tag (o: DotNet.TestOptions) =
    { o.WithCommon dotnetOptions with
          Configuration = DotNet.BuildConfiguration.Debug
          ResultsDirectory = Some report
          NoBuild = true
          Framework = Some "net6.0"
          Settings = Some "./_Generated/coverletArgs.runsettings"
          Collect = Some "XPlat Code Coverage" }
    |> (testWithCLITaggedArguments tag)

let coverletTestOptionsSample report tag (o: DotNet.TestOptions) =
    { coverletTaggedTestOptions report tag o with
          Settings = Some "./Build/coverletArgs.sample.runsettings"
          Collect = Some "XPlat Code Coverage" }

let misses = ref 0

let uncovered (path: string) =
    misses.Value <- 0

    !!path
    |> Seq.collect
        (fun f ->
            let xml = XDocument.Load f

            xml.Descendants(XName.Get("Uncoveredlines"))
            |> Seq.filter
                (fun x ->
                    match String.IsNullOrWhiteSpace x.Value with
                    | false -> true
                    | _ ->
                        sprintf "No coverage from '%s'" f
                        |> Trace.traceImportant

                        misses.Value <- 1 + misses.Value
                        false)
            |> Seq.map
                (fun e ->
                    let coverage = e.Value

                    match Int32.TryParse coverage with
                    | (false, _) ->
                        printfn "%A" xml

                        Assert.Fail(
                            "Could not parse uncovered line value '"
                            + coverage
                            + "'"
                        )

                        (0, f)
                    | (_, numeric) ->
                        printfn "%s : %A" (f |> Path.GetDirectoryName |> Path.GetFileName) numeric
                        // if numeric > 0 then
                        //   printfn "%A" xml
                        (numeric, f)))
    |> Seq.toList

let coverageSummary _ =
    let numbers = uncovered "_Reports/_Unit*/Summary.xml"

    if numbers
       |> List.tryFind
           (fun (n, f) ->
               if (f |> Path.GetDirectoryName |> Path.GetFileName) = "_UnitTestWithCoverlet" then
                   n > 0 && n < 100 // don't expect to get that high
               // w/o flakeout or other ones failing too
               else
                   n > 0)
       |> Option.isSome
       || misses.Value > 0 then
        Assert.Fail("Coverage is too low")

let msbuildCommon (p: MSBuildParams) =
    { p with
          Verbosity = Some MSBuildVerbosity.Normal
          ConsoleLogParameters = []
          DistributedLoggers = None
          DisableInternalBinLog = true
          Properties = [ "DebugSymbols", "True" ] }

let withDebug (p: MSBuildParams) =
    { p with
          Properties =
              ("DebugType", "Portable")
              :: ("Configuration", "Debug") :: p.Properties
          DoRestore = true }

let withRelease (p: MSBuildParams) =
    { p with
          Properties = ("Configuration", "Release") :: p.Properties
          DoRestore = true }

let splitCommandLine line =
    line
    |> if Environment.isWindows then
           BlackFox.CommandLine.MsvcrCommandLine.parse
       else
           BlackFox.CommandLine.MonoUnixCommandLine.parse
    |> Seq.toList

let doMSBuild config overrider proj =
    let f = msbuildCommon >> config

    match overrider with
    | None -> MSBuild.build f proj
    | Some dll ->
        let (_, args) = MSBuild.buildArgs f
        let arglist = (splitCommandLine args) @ [ proj ]

        CreateProcess.fromRawCommand dll arglist
        |> DotNet.prefixProcess dotnetOptions [ dll ]
        |> Proc.run
        |> fun p -> Assert.That(p.ExitCode, Is.EqualTo 0)

let msbuildRelease = doMSBuild withRelease
let msbuildDebug = doMSBuild withDebug

let dotnetOptionsWithSkipGtkInstall (o: DotNet.Options) =
    let env =
        o.Environment.Add("SkipGtkInstall", "True")

    o.WithEnvironment env

let dotnetBuildRelease proj =
    DotNet.build
        (fun p ->
            { p.WithCommon(dotnetOptions >> dotnetOptionsWithSkipGtkInstall) with
                  Configuration = DotNet.BuildConfiguration.Release }
            |> buildWithCLIArguments)
        (Path.GetFullPath proj)

let dotnetBuildDebug proj =
    DotNet.build
        (fun p ->
            { p.WithCommon(dotnetOptions >> dotnetOptionsWithSkipGtkInstall) with
                  Configuration = DotNet.BuildConfiguration.Debug }
            |> buildWithCLIArguments)
        (Path.GetFullPath proj)

let collectorTestOptions tag (o: DotNet.TestOptions) =
    let settings = XDocument()
    let xname n = XName.Get n

    let ensureHas (parent: XContainer) childName =
        match parent.Descendants(xname childName) |> Seq.tryHead with
        | Some child -> child
        | _ ->
            let extra = XElement(xname childName)
            parent.Add extra
            extra

    let expected =
        Path.getFullName "_Binaries/AltCover.DataCollector/Debug+AnyCPU/netstandard2.0/AltCover.DataCollector.dll"

    let rs = ensureHas settings "RunSettings"

    let ip1 =
        ensureHas rs "InProcDataCollectionRunSettings"

    let ip2 = ensureHas ip1 "InProcDataCollectors"

    let name = AssemblyName.GetAssemblyName(expected)

    let altcover =
        XElement(
            xname "InProcDataCollector",
            XAttribute(xname "friendlyName", "AltCover"),
            XAttribute(
                xname "uri",
                "InProcDataCollector://AltCover/Recorder/"
                + name.Version.ToString()
            ),
            XAttribute(xname "assemblyQualifiedName", "AltCover.DataCollector, " + name.FullName),
            XAttribute(xname "codebase", expected),
            XElement(xname "Configuration", XElement(xname "Offload", XText("true")))
        )

    ip2.Add(altcover)

    let extended =
        Path.getFullName ("_Binaries/" + tag + ".runsettings")

    settings.Save(extended)

    { o with Settings = Some extended }

// Information.getCurrentHash()
let commitHash = Information.getCurrentSHA1 (".")
let infoV = Information.showName "." commitHash
printfn "Build at %A" infoV

// let hash = System.Security.Cryptography.SHA256.Create()

// let formatSecret (s : string) =
//   if s |> isNull
//   then "(null)"
//   else if String.IsNullOrEmpty s
//        then "(empty)"
//        else if String.IsNullOrWhiteSpace s
//             then "(whitespace)"
//             else s
//                  |> System.Text.Encoding.UTF8.GetBytes
//                  |> hash.ComputeHash
//                  |> Convert.ToBase64String

//----------------------------------------------------------------

let _Target s f =
    let doTarget s f =
        let banner x =
            printfn ""
            printfn " ****************** %s ******************" s
            f x

        Target.create s banner

    Target.description s
    doTarget s f

    let s2 = "Replay" + s
    Target.description s2
    doTarget s2 f

// Preparation

_Target "RebuildPaketLock" ignore

_Target "Preparation" ignore

_Target
    "PreClean"
    (fun _ ->
        // dir -Recurse *ssemblyAttributes.cs | % { del -Force $_.FullName }
        !! "**/*ssemblyAttributes.cs"
        |> Seq.map Path.GetFullPath
        |> Seq.toList
        |> List.iter File.delete)

_Target
    "Clean"
    (fun _ ->
        printfn "Cleaning the build and deploy folders"
        Actions.Clean())

_Target
    "SetVersion"
    (fun _ ->

        // patch gendarme
        let configjson =
            File.ReadAllText("./.config/dotnet-tools.json")

        let json = Manatee.Json.JsonValue.Parse configjson

        let gendarmeVersion =
            json.Object.["tools"].Object.["altcode.gendarme-tool"]
                .Object.["version"]
                .String

        let project1 = XDocument.Load("./Build/NuGet.csproj")

        let pr =
            project1.Descendants(XName.Get "PackageReference")
            |> Seq.find (fun pr -> pr.Attribute(XName.Get "Include").Value = "altcode.gendarme")

        pr.Attribute(XName.Get "version").Value <- gendarmeVersion
        project1.Save("./Build/NuGet.csproj")

        let project2 =
            XDocument.Load(
                "./AltCover.ValidateGendarmeEmulation/AltCover.ValidateGendarmeEmulation.fsproj",
                System.Xml.Linq.LoadOptions.PreserveWhitespace
            )

        let gv =
            project2.Descendants(XName.Get "GendarmeVersion")
            |> Seq.head

        gv.Value <- gendarmeVersion

        project2.Save(
            "./AltCover.ValidateGendarmeEmulation/AltCover.ValidateGendarmeEmulation.fsproj",
            System.Xml.Linq.SaveOptions.DisableFormatting
        )

        // patch coveralls.io for github actions
        let coverallsdll =
            ("./packages/"
             + (packageVersion "coveralls.io")
             + "/tools/Coveralls.dll")
            |> Path.getFullName

        Shell.copyFile coverallsdll "./ThirdParty/Coveralls.dll"

        let coverallspdb =
            ("./packages/"
             + (packageVersion "coveralls.io")
             + "/tools/Coveralls.pdb")
            |> Path.getFullName

        Shell.copyFile coverallspdb "./ThirdParty/Coveralls.pdb"

        let appveyor =
            Environment.environVar "APPVEYOR_BUILD_VERSION"

        let github =
            Environment.environVar "GITHUB_RUN_NUMBER"

        let version = Actions.GetVersionFromYaml()

        let ci =
            if String.IsNullOrWhiteSpace appveyor then
                if String.IsNullOrWhiteSpace github then
                    String.Empty
                else
                    version.Replace("{build}", github + "-github")
            else
                appveyor

        let (v, majmin, y) = Actions.LocalVersion ci version
        Version.Value <- v

        let copy =
            sprintf "Â© 2010-%d by Steve Gilham <SteveGilham@users.noreply.github.com>" y

        Copyright.Value <- "Copyright " + copy

        Directory.ensure "./_Generated"
        Shell.copyFile "./AltCover.Engine/Abstract.fsi" "./AltCover.Engine/Abstract.fs"
        Actions.InternalsVisibleTo(Version.Value)

        [ "./_Generated/AssemblyVersion.fs"
          "./_Generated/AssemblyVersion.cs" ]
        |> List.iter
            (fun f ->
                let from =
                    ("./Build" @@ (Path.GetFileName f)) + ".txt"

                let text = File.ReadAllText from

                let newtext =
                    String.Format(
                        text,
                        majmin,
                        Version.Value.Split([| '-' |]).[0],
                        commitHash,
                        Information.getBranchName ("."),
                        y
                    )

                File.WriteAllText(f, newtext))

        let hack =
            """namespace AltCover
module SolutionRoot =
  let location = """
            + "\"\"\""
            + (Path.getFullName ".")
            + "\"\"\""

        let path = "_Generated/SolutionRoot.fs"

        // Update the file only if it would change
        let old =
            if File.Exists(path) then
                File.ReadAllText(path)
            else
                String.Empty

        if not (old.Equals(hack)) then
            File.WriteAllText(path, hack)

        do
            let xml =
                XDocument.Load("./AltCover.Recorder/Strings.resx")

            use resw =
                new System.Resources.ResourceWriter("./AltCover.Recorder/Strings.resources")

            xml.Descendants(XName.Get "data")
            |> Seq.iter
                (fun d ->
                    let key = d.Attribute(XName.Get "name").Value

                    let value =
                        d.Descendants(XName.Get "value") |> Seq.head

                    resw.AddResource(key, value.Value))

            resw.Close()

        let text =
            File.ReadAllText "./Build/coverletArgs.runsettings"

        let name =
            System.Reflection.AssemblyName.GetAssemblyName coverletcollector

        let newtext =
            String.Format(text, name.Version, name.FullName, coverletcollector)

        File.WriteAllText("./_Generated/coverletArgs.runsettings", newtext))

// Basic compilation

_Target "Compilation" ignore

_Target
    "BuildRelease"
    (fun _ ->
        try
            [ "./AltCover.sln"
              "./AltCover.Visualizer.sln"
              "MCS.sln" ]
            |> Seq.iter dotnetBuildRelease

            // document cmdlets ahead of packaging
            let packages =
                let xml =
                    "./AltCover.PowerShell/AltCover.PowerShell.fsproj"
                    |> Path.getFullName
                    |> XDocument.Load

                xml.Descendants(XName.Get("PackageReference"))
                |> Seq.map
                    (fun x ->
                        let incl = x.Attribute(XName.Get("Include"))
                        let update = x.Attribute(XName.Get("Update"))
                        let version = x.Attribute(XName.Get("Version")).Value

                        if incl |> isNull then
                            (update.Value, version)
                        else
                            (incl.Value, version))
                |> Map.ofSeq

            let packageVersionPart (p: string) =
                nugetCache
                + "/"
                + p.ToLowerInvariant()
                + "/"
                + (packages.Item p)
                + "/lib/netstandard2.0/"

            Shell.copyFile
                ("./_Binaries/AltCover.PowerShell/Release+AnyCPU/netstandard2.0/FSharp.Core.dll")
                ((packageVersionPart "FSharp.Core")
                 + "FSharp.Core.dll")

            Shell.copyFile
                ("./_Binaries/AltCover.PowerShell/Release+AnyCPU/netstandard2.0/System.Management.Automation.dll")
                ((packageVersionPart "PowerShellStandard.Library")
                 + "System.Management.Automation.dll")

            let cmdlets =
                "./_Binaries/AltCover.PowerShell/Release+AnyCPU/netstandard2.0/AltCover.PowerShell.dll"
                |> Path.getFullName

            if Environment.isWindows then // the Jolt comment reader library is sadly windows/fullframework bound
                // see Jolt.XmlDocCommentReaderSettings.CreateDefaultSettings()
                //  https://github.com/red-gate/JoltNet-core/tree/master/Jolt
                Actions.RunDotnet
                    dotnetOptions
                    ""
                    ("--roll-forward Major "
                     + xmldoc2cmdletdoc
                     + " -strict "
                     + cmdlets)
                    "documenting cmdlets"
        with
        | x ->
            printfn "%A" x
            reraise ())

_Target "BuildRecorder" (fun _ -> msbuildDebug MSBuildPath "./AltCover.Recorder.sln")

_Target "BuildReleaseRecorder" (fun _ -> msbuildRelease MSBuildPath "./AltCover.Recorder.sln")

_Target
    "BuildDebug"
    (fun _ ->
        Directory.ensure "./_SourceLink"
        Shell.copyFile "./_SourceLink/Class2.cs" "./Samples/Sample14/Sample14/Class2.txt"

        (if Environment.isWindows then
             let temp = Environment.environVar "TEMP"
             Shell.copyFile (temp @@ "/Sample14.SourceLink.Class3.cs")
         else
             Directory.ensure "/tmp/.AltCover_SourceLink"
             Shell.copyFile "/tmp/.AltCover_SourceLink/Sample14.SourceLink.Class3.cs")
            "./Samples/Sample14/Sample14/Class3.txt"

        // net20 and such
        [ msbuildDebug MSBuildPath
          msbuildRelease MSBuildPath ]
        |> List.iter (fun f -> f "./AltCover.Recorder.sln")

        [ "./AltCover.sln"
          "./AltCover.Visualizer.sln"
          "./MCS.sln"
          "./Samples/Sample14/Sample14.sln"
          "./Samples/Sample28/SourceGenerators.sln" ]
        |> Seq.iter dotnetBuildDebug

        Shell.copy "./_SourceLink" (!! "./_Binaries/Sample14/Debug+AnyCPU/netcoreapp2.1/*"))

_Target
    "BuildMonoSamples"
    (fun _ ->
        [ "./Samples/Sample8/Sample8.csproj" ]
        |> Seq.iter dotnetBuildDebug // build to embed on non-Windows

        let mcs =
            "_Binaries/MCS/Release+AnyCPU/net472/MCS.exe"

        [ ("./_Mono/Sample1",
           [ "-debug"
             "-out:./_Mono/Sample1/Sample1.exe"
             "./Samples/Sample1/Program.cs" ])

          ("./_Mono/Sample3",
           [ "-target:library"
             "-debug"
             "-D:MONO"
             "-out:./_Mono/Sample3/Sample3.dll"
             "-lib:./packages/Mono.Cecil.0.11.4/lib/net40"
             "-r:Mono.Cecil.dll"
             "./Samples/Sample3/Class1.cs" ]) ]

        |> Seq.iter
            (fun (dir, cmd) ->
                Directory.ensure dir

                ("Mono compilation of '"
                 + String.Join(" ", cmd)
                 + "' failed")
                |> Actions.Run(mcs, ".", cmd)))

_Target
    "BuildSample31"
    (fun _ ->
        let mcs =
            "_Binaries/MCS/Release+AnyCPU/net472/MCS.exe"

        [ ("./_Mono/Sample31",
           [ "-target:library"
             "-debug"
             "-D:MONO"
             "-out:./_Mono/Sample31/Sample31.dll"
             "-lib:./packages/Mono.Cecil.0.11.4/lib/net40"
             "-r:Mono.Cecil.dll"
             "./Samples/Sample31/Class1.cs" ]) ]
        |> Seq.iter
            (fun (dir, cmd) ->
                Directory.ensure dir

                ("Mono compilation of '"
                 + String.Join(" ", cmd)
                 + "' failed")
                |> Actions.Run(mcs, ".", cmd)))

// Code Analysis

_Target "Analysis" ignore

_Target
    "Lint"
    (fun _ ->
        let cfg = Path.getFullName "./fsharplint.json"

        let doLint f =
            CreateProcess.fromRawCommand "dotnet" [ "fsharplint"; "lint"; "-l"; cfg; f ]
            |> CreateProcess.setEnvironmentVariable "DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX" "2"
            |> CreateProcess.ensureExitCodeWithMessage "Lint issues were found"
            |> Proc.run

        let doLintAsync f = async { return (doLint f).ExitCode }

        let throttle x =
            Async.Parallel(x, System.Environment.ProcessorCount)

        let demo = Path.getFullName "./Demo"
        let regress = Path.getFullName "./RegressionTesting"
        let sample = Path.getFullName "./Samples"

        let failOnIssuesFound (issuesFound: bool) =
            Assert.That(issuesFound, Is.False, "Lint issues were found")

        [ !! "./**/*.fsproj"
          |> Seq.sortBy (Path.GetFileName)
          |> Seq.filter
              (fun f ->
                  ((f.Contains demo)
                   || (f.Contains regress)
                   || (f.Contains sample))
                  |> not)
          !! "./Build/*.fsx" |> Seq.map Path.GetFullPath ]
        |> Seq.concat
        |> Seq.map doLintAsync
        |> throttle
        |> Async.RunSynchronously
        |> Seq.exists (fun x -> x <> 0)
        |> failOnIssuesFound)

//(fun _ ->
//    let failOnIssuesFound (issuesFound: bool) =
//        Assert.That(issuesFound, Is.False, "Lint issues were found")

//    try
//        let options =
//            { Lint.OptionalLintParameters.Default with
//                  Configuration = FromFile(Path.getFullName "./fsharplint.json") }

//        [ !! "**/*.fsproj"
//          |> Seq.collect (fun n -> !!(Path.GetDirectoryName n @@ "*.fs"))
//          |> Seq.distinct
//          !! "./Build/*.fsx" |> Seq.map Path.GetFullPath ]
//        |> Seq.concat
//        |> Seq.collect
//            (fun f ->
//                match Lint.lintFile options f with
//                | Lint.LintResult.Failure x -> failwithf "%A" x
//                | Lint.LintResult.Success w ->
//                    w
//                    |> Seq.filter (fun x -> x.Details.SuggestedFix |> Option.isSome))
//        |> Seq.fold
//            (fun _ x ->
//                printfn
//                    "Info: %A\r\n Range: %A\r\n Fix: %A\r\n===="
//                    x.Details.Message
//                    x.Details.Range
//                    x.Details.SuggestedFix

//                true)
//            false
//        |> failOnIssuesFound
//    with ex ->
//        printfn "%A" ex
//        reraise ())

_Target
    "Gendarme"
    (fun _ -> // Needs debug because release is compiled --standalone which contaminates everything

        Directory.ensure "./_Reports"

        [ ("./Build/common-rules.xml",
           [ "_Binaries/AltCover.Engine/Debug+AnyCPU/netstandard2.0/AltCover.Engine.dll"
             "_Binaries/AltCover/Debug+AnyCPU/netcoreapp2.0/AltCover.dll"
             "_Binaries/AltCover.Recorder/Debug+AnyCPU/net20/AltCover.Recorder.dll"
             "_Binaries/AltCover.Async/Debug+AnyCPU/net46/AltCover.Async.dll"
             "_Binaries/AltCover.PowerShell/Debug+AnyCPU/netstandard2.0/AltCover.PowerShell.dll"
             "_Binaries/AltCover.Fake/Debug+AnyCPU/netstandard2.0/AltCover.Fake.dll"
             "_Binaries/AltCover.DotNet/Debug+AnyCPU/netstandard2.0/AltCover.DotNet.dll"
             "_Binaries/AltCover.Toolkit/Debug+AnyCPU/netstandard2.0/AltCover.Toolkit.dll"
             "_Binaries/AltCover.UICommon/Debug+AnyCPU/netstandard2.0/AltCover.UICommon.dll"
             "_Binaries/AltCover.Visualizer/Debug+AnyCPU/netcoreapp2.1/AltCover.Visualizer.dll" // GTK3 (obsolete)
             "_Binaries/AltCover.Fake.DotNet.Testing.AltCover/Debug+AnyCPU/netstandard2.0/AltCover.Fake.DotNet.Testing.AltCover.dll" ])
          ("./Build/common-rules.xml",  // Framework builds
           [ "_Binaries/AltCover/Debug+AnyCPU/net472/AltCover.exe" // framework builds
             "_Binaries/AltCover.Visualizer/Debug+AnyCPU/net472/AltCover.Visualizer.exe" ])
          ("./Build/common-rules.xml",
           [ "_Binaries/AltCover/Debug+AnyCPU/netcoreapp2.1/AltCover.dll" // global tool builds
             "_Binaries/AltCover.Avalonia/Debug+AnyCPU/netcoreapp2.1/AltCover.Visualizer.dll" ])
          ("./Build/csharp-rules.xml",
           [ "_Binaries/AltCover.DataCollector/Debug+AnyCPU/netstandard2.0/AltCover.DataCollector.dll"
             "_Binaries/AltCover.Monitor/Debug+AnyCPU/netstandard2.0/AltCover.Local.Monitor.dll"
             "_Binaries/AltCover.FontSupport/Debug+AnyCPU/netstandard2.0/AltCover.FontSupport.dll"
             "_Binaries/AltCover.Cake/Debug+AnyCPU/netstandard2.0/AltCover.Cake.dll" ])
          ("./Build/csharp-rules.xml",  // Framework builds
           [ "_Binaries/AltCover.Monitor/Debug+AnyCPU/net20/AltCover.Local.Monitor.dll"
             "_Binaries/AltCover.FontSupport/Debug+AnyCPU/net472/AltCover.FontSupport.dll" ]) ]
        |> Seq.iter
            (fun (ruleset, files) ->
                Gendarme.run
                    { Gendarme.Params.Create() with
                          WorkingDirectory = "."
                          Severity = Gendarme.Severity.All
                          Confidence = Gendarme.Confidence.All
                          Configuration = ruleset
                          Console = true
                          Log = "./_Reports/gendarme.html"
                          LogKind = Gendarme.LogKind.Html
                          Targets = files
                          ToolType = ToolType.CreateLocalTool()
                          FailBuildOnDefect = true }))

_Target
    "FxCop"
    (fun _ ->
        Directory.ensure "./_Reports"

        let dumpSuppressions (report: String) =
            let x = XDocument.Load report
            let messages = x.Descendants(XName.Get "Message")

            messages
            |> Seq.iter
                (fun m ->
                    let mpp = m.Parent.Parent
                    let target = mpp.Name.LocalName
                    let tname = mpp.Attribute(XName.Get "Name").Value

                    let (text, fqn) =
                        match target with
                        | "Namespace" -> ("namespace", tname)
                        | "Resource" -> ("resource", tname)
                        | "File"
                        | "Module" -> ("module", String.Empty)
                        | "Type" ->
                            let spp = mpp.Parent.Parent

                            ("type",
                             spp.Attribute(XName.Get "Name").Value
                             + "."
                             + tname)
                        | _ ->
                            let spp = mpp.Parent.Parent
                            let sp4 = spp.Parent.Parent

                            ("member",
                             sp4.Attribute(XName.Get "Name").Value
                             + "."
                             + spp.Attribute(XName.Get "Name").Value
                             + "."
                             + tname)

                    let text2 = "[<assembly: SuppressMessage("

                    let id = m.Attribute(XName.Get "Id")

                    let text3 =
                        (if id |> isNull |> not then
                             ", MessageId=\"" + id.Value + "\""
                         else
                             String.Empty)
                        + ", Justification=\"\")>]"

                    let category = m.Attribute(XName.Get "Category").Value
                    let checkId = m.Attribute(XName.Get "CheckId").Value
                    let name = m.Attribute(XName.Get "TypeName").Value

                    let finish t t2 =
                        let t5 =
                            t2
                            + "\""
                            + category
                            + "\", \""
                            + checkId
                            + ":"
                            + name
                            + "\""

                        if t |> isNull || t = "module" then
                            t5 + text3
                        else
                            t5
                            + ", Scope=\""
                            + t
                            + "\", Target=\""
                            + fqn
                            + "\""
                            + text3

                    printfn "%s" (finish text text2))

        let deprecatedRules =
            [ "-Microsoft.Usage#CA2202" // double dispose
              "-Microsoft.Design#CA2210" ] // should strongname

        let gendarmeRules =
            [ "-Microsoft.Design#CA1016" // :MarkAssembliesWithAssemblyVersion"
              "-Microsoft.Performance#CA1822" // :MarkMembersAsStatic"
              "-Microsoft.Design#CA1031" // :DoNotCatchGeneralExceptionTypes"
              //"-Microsoft.Usage#CA2208" // :InstantiateArgumentExceptionsCorrectly"
              "-Microsoft.Usage#CA1801" // :ReviewUnusedParameters"
              //"-Microsoft.Globalization#CA1307" // :SpecifyStringComparison"
              "-Microsoft.Design#CA1028" // :EnumStorageShouldBeInt32"
              "-Microsoft.Design#CA1002" ] // :DoNotExposeGenericLists"

        let nonFsharpRules =
            [ "-Microsoft.Design#CA1006" // nested generics
              "-Microsoft.Design#CA1034" // nested classes being visible
              "-Microsoft.Design#CA1062" // null checks,  In F#!
              "-Microsoft.Naming#CA1709" // defer to the Gendarme casing rule for implicit 'a
              "-Microsoft.Naming#CA1715" // defer to the Gendarme naming rule for implicit 'a
              "-Microsoft.Usage#CA2235" // closures being serializable
              "-Microsoft.Maintainability#CA1506" ] // AvoidExcessiveClassCoupling

        let standardRules =
            [ "-Microsoft.Design#CA1020" // small namespaces
              "-Microsoft.Usage#CA2243" ] // :AttributeStringLiteralsShouldParseCorrectly"

        let minimalRules =
            List.concat [ deprecatedRules
                          standardRules
                          gendarmeRules ]

        let defaultRules =
            List.concat [ deprecatedRules
                          standardRules
                          gendarmeRules
                          nonFsharpRules ]

        let defaultCSharpRules =
            List.concat [ deprecatedRules
                          standardRules
                          gendarmeRules
                          [ "-Microsoft.Design#CA1026:DefaultParametersShouldNotBeUsed" ] ]

        let refdir =
            @"C:\Program Files\dotnet\sdk\6.0.101\ref" // TODO generate

        // net20 targets
        [ ([ "_Binaries/AltCover.Recorder/Debug+AnyCPU/net20/AltCover.Recorder.dll"
             "_Binaries/AltCover.Monitor/Debug+AnyCPU/net20/AltCover.Local.Monitor.dll" ],
           [],
           "-Microsoft.Naming#CA1703:ResourceStringsShouldBeSpelledCorrectly"
           :: defaultRules) ]
        |> Seq.iter
            (fun (files, types, ruleset) ->
                try
                    files
                    |> FxCop.run
                        { FxCop.Params.Create() with
                              WorkingDirectory = "."
                              ToolPath = Option.get fxcop
                              UseGAC = true
                              Verbose = false
                              ReportFileName = "_Reports/FxCopReport.xml"
                              Types = types
                              Rules = ruleset
                              FailOnError = FxCop.ErrorLevel.Warning
                              IgnoreGeneratedCode = true }
                with
                | _ ->
                    dumpSuppressions "_Reports/FxCopReport.xml"
                    reraise ())

        [ (fxcop,  // framework targets
           String.Empty,
           (if String.IsNullOrEmpty(Environment.environVar "APPVEYOR_BUILD_VERSION") then
                [ "_Binaries/AltCover.FontSupport/Debug+AnyCPU/net472/AltCover.FontSupport.dll" // dual build intentional
                  "_Binaries/AltCover/Debug+AnyCPU/net472/AltCover.exe" ]
            else // HACK HACK HACK
                [ "_Binaries/AltCover/Debug+AnyCPU/net472/AltCover.exe" ]),
           [],
           minimalRules)
          (fxcop,  // framework targets
           String.Empty,
           [ "_Binaries/AltCover.Async/Debug+AnyCPU/net46/AltCover.Async.dll"
             "_Binaries/AltCover.Visualizer/Debug+AnyCPU/net472/AltCover.Visualizer.exe" ],  // GTK2
           [],
           defaultRules)
          (dixon,
           refdir,
           [ // new platform "_Binaries/AltCover.Visualizer/Debug+AnyCPU/netcoreapp2.1/AltCover.Visualizer.dll" // GTK3
             "_Binaries/AltCover.Visualizer/Debug+AnyCPU/netstandard2.0/AltCover.Visualizer.dll" // surrogate for above
             "_Binaries/AltCover.PowerShell/Debug+AnyCPU/netstandard2.0/AltCover.PowerShell.dll"
             "_Binaries/AltCover.Fake/Debug+AnyCPU/netstandard2.0/AltCover.Fake.dll"
             "_Binaries/AltCover.Fake.DotNet.Testing.AltCover/Debug+AnyCPU/netstandard2.0/AltCover.Fake.DotNet.Testing.AltCover.dll" ],
           [],
           defaultRules)
          (dixon,
           refdir,
           [ "_Binaries/AltCover.FontSupport/Debug+AnyCPU/netstandard2.0/AltCover.FontSupport.dll"
             // new platform "_Binaries/AltCover/Debug+AnyCPU/netcoreapp2.0/AltCover.dll" // same as net472
             "_Binaries/AltCover.DataCollector/Debug+AnyCPU/netstandard2.0/AltCover.DataCollector.dll" ],
           [],
           minimalRules)
          (dixon,
           refdir,
           [ "_Binaries/AltCover/Debug+AnyCPU/netstandard2.0/AltCover.dll" ], // new platform "_Binaries/AltCover/Debug+AnyCPU/netcoreapp2.1/AltCover.dll"
           [],
           minimalRules)
          //          (dixon, // new platform
//           refdir,
//           [ // new platform "_Binaries/AltCover.Avalonia/Debug+AnyCPU/netcoreapp2.1/AltCover.Visualizer.dll" // Avalonia
//             //  GetReaderForFile returned an unexpected HResult: 0x80004005. // same at net472 if built thus
//             "_Binaries/AltCover.Avalonia/Debug+AnyCPU/netstandard2.0/AltCover.Visualizer.dll" ], [], defaultRules)
          (dixon,
           refdir,
           [ "_Binaries/AltCover.Cake/Debug+AnyCPU/netstandard2.0/AltCover.Cake.dll" ],
           [],
           defaultCSharpRules)
          (dixon,
           refdir,
           [ "_Binaries/AltCover.UICommon/Debug+AnyCPU/netstandard2.0/AltCover.UICommon.dll"
             "_Binaries/AltCover.Toolkit/Debug+AnyCPU/netstandard2.0/AltCover.Toolkit.dll"
             "_Binaries/AltCover.Monitor/Debug+AnyCPU/netstandard2.0/AltCover.Local.Monitor.dll"
             "_Binaries/AltCover.DotNet/Debug+AnyCPU/netstandard2.0/AltCover.DotNet.dll" ],
           [],
           defaultRules)
          (dixon,
           refdir,
           [ "_Binaries/AltCover.Engine/Debug+AnyCPU/netstandard2.0/AltCover.Engine.dll" ],
           [],
           List.concat [ defaultRules
                         [ "-Microsoft.Naming#CA1703" // spelling in resources
                           "-Microsoft.Performance#CA1810" ] ]) ] // Static module initializers in $Type classes
        |> Seq.iter
            (fun (tool, platform, files, types, ruleset) ->
                try
                    files
                    |> FxCop.run
                        { FxCop.Params.Create() with
                              WorkingDirectory = "."
                              DependencyDirectories =
                                  [ "./ThirdParty/gtk-sharp2"
                                    nugetCache
                                    @@ "blackfox.commandline/1.0.0/lib/netstandard2.0"
                                    nugetCache
                                    @@ "cake.common/1.1.0/lib/netstandard2.0"
                                    nugetCache @@ "cake.core/1.1.0/lib/netstandard2.0"
                                    nugetCache
                                    @@ "fake.core.environment/5.21.0/lib/netstandard2.0"
                                    nugetCache
                                    @@ "fake.core.process/5.21.0/lib/netstandard2.0"
                                    nugetCache
                                    @@ "fake.core.trace/5.21.0/lib/netstandard2.0"
                                    nugetCache
                                    @@ "fake.dotnet.cli/5.21.0/lib/netstandard2.0"
                                    nugetCache
                                    @@ "fake.dotnet.msbuild/5.21.0/lib/netstandard2.0"
                                    nugetCache
                                    @@ "fsharp.core/6.0.1/lib/netstandard2.0"
                                    nugetCache
                                    @@ "gdksharp/3.24.24.34/lib/netstandard2.0"
                                    nugetCache
                                    @@ "glibsharp/3.24.24.34/lib/netstandard2.0"
                                    nugetCache
                                    @@ "gtksharp/3.24.24.34/lib/netstandard2.0"
                                    nugetCache
                                    @@ "mono.cecil/0.11.4/lib/netstandard2.0"
                                    nugetCache
                                    @@ "mono.options/6.12.0.148/lib/netstandard2.0"
                                    nugetCache
                                    @@ "microsoft.build.framework/16.0.461/lib/netstandard2.0"
                                    nugetCache
                                    @@ "microsoft.build.utilities.core/16.0.461/lib/netstandard2.0"
                                    nugetCache
                                    @@ "microsoft.testplatform.objectmodel/16.1.1/lib/netstandard1.5"
                                    nugetCache
                                    @@ "microsoft.netframework.referenceassemblies.net472/1.0.2/build/.NETFramework/v4.7.2"
                                    nugetCache
                                    @@ "pangosharp/3.24.24.34/lib/netstandard2.0"
                                    nugetCache
                                    @@ "powershellstandard.library/5.1.0/lib/netstandard2.0" ]
                              ToolPath = Option.get tool
                              PlatformDirectory = platform
                              UseGAC = true
                              Verbose = false
                              ReportFileName = "_Reports/FxCopReport.xml"
                              Types = types
                              Rules = ruleset
                              FailOnError = FxCop.ErrorLevel.Warning
                              IgnoreGeneratedCode = true }
                with
                | _ ->
                    dumpSuppressions "_Reports/FxCopReport.xml"
                    reraise ())

        try
            [ "_Binaries/AltCover.PowerShell/Debug+AnyCPU/netstandard2.0/AltCover.PowerShell.dll" ]
            |> FxCop.run
                { FxCop.Params.Create() with
                      WorkingDirectory = "."
                      ToolPath = Option.get dixon
                      PlatformDirectory = refdir
                      DependencyDirectories =
                          [ nugetCache
                            @@ "fsharp.core/6.0.1/lib/netstandard2.0"
                            nugetCache
                            @@ "powershellstandard.library/5.1.0/lib/netstandard2.0" ]
                      UseGAC = true
                      Verbose = false
                      ReportFileName = "_Reports/FxCopReport.xml"
                      RuleLibraries = [ Path.getFullName "ThirdParty/Microsoft.PowerShell.CodeAnalysis.16.dll" ]
                      FailOnError = FxCop.ErrorLevel.Warning
                      IgnoreGeneratedCode = true }
        with
        | _ ->
            dumpSuppressions "_Reports/FxCopReport.xml"
            reraise ())
// Unit Test

_Target
    "UnitTest"
    (fun _ ->
        let reports = Path.getFullName "./_Reports"

        CreateProcess.fromRawCommand
            pwsh
            [ "-NoProfile"
              "./Build/merge-coverage.ps1" ]
        |> CreateProcess.withWorkingDirectory "."
        |> Proc.run
        |> (Actions.AssertResult "pwsh")

        let coverage =
            reports
            @@ "CombinedTestWithAltCoverRunner.coveralls"

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_Coveralls" })
            [ coverage ]

        if Environment.isWindows
           && [ "APPVEYOR_BUILD_NUMBER"
                "GITHUB_RUN_NUMBER" ]
              |> List.exists (Environment.environVar
                              >> String.IsNullOrWhiteSpace
                              >> not)
        then
            let coveralls =
                ("./packages/"
                 + (packageVersion "coveralls.io")
                 + "/tools/coveralls.net.exe")
                |> Path.getFullName

            Actions.Run(coveralls, "_Reports", [ "--opencover"; coverage; "--debug" ]) "Coveralls upload failed"

        printfn "Dump uncovered lines"

        CreateProcess.fromRawCommand
            pwsh
            [ "-NoProfile"
              "./Build/dump-uncovered.ps1" ]
        |> CreateProcess.withWorkingDirectory "."
        |> Proc.run
        |> (Actions.AssertResult "pwsh")

        coverageSummary ())

_Target "UncoveredUnitTest" ignore

let NUnitRetry f spec =
    let rec doNUnitRetry depth f spec =
        try
            if File.Exists spec then
                File.Delete spec

            NUnit3.run (f >> (fun p -> { p with ResultSpecs = [ spec ] }))
        with
        | x ->
            printfn "doNUnitRetry caught %A" x

            if depth > 2 then
                printfn "Recursion limited"
                reraise ()

            if File.Exists spec then
                let xml =
                    "./Build/NuGet.csproj"
                    |> Path.getFullName
                    |> XDocument.Load

                let summary =
                    xml.Descendants(XName.Get "test-run") |> Seq.head

                let failcount =
                    summary.Attribute(XName.Get "failed").Value

                if failcount = "0" then
                    doNUnitRetry (depth + 1) f spec
                else
                    printfn "Actual failures found %A" failcount
                    reraise ()
            else
                printfn "Report not found"
                reraise ()

    doNUnitRetry 0 f spec

_Target
    "JustRecorderUnitTest"
    (fun _ ->
        Directory.ensure "./_Reports"

        try
            let recArgs =
                [ "--noheader"
                  "--work=."
                  "--result=./_Reports/JustRecorderUnitTestReport.xml"
                  Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472/AltCover.Recorder.Tests.dll" ]

            Actions.Run(nunitConsole, ".", recArgs) "Recorder NUnit failed"

            let rec2Args =
                [ "--noheader"
                  "--work=."
                  "--result=./_Reports/JustRecorder2UnitTestReport.xml"
                  Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net20/AltCover.Recorder.Tests.dll" ]

            Actions.Run(nunitConsole, ".", rec2Args) "Recorder NUnit failed"

        with
        | x ->
            printfn "%A" x
            reraise ())

"BuildRecorder" ==> "JustRecorderUnitTest"

_Target
    "JustUnitTest"
    (fun _ ->
        Directory.ensure "./_Reports"

        try
            let baseArgs =
                [ "--noheader"
                  "--work=."
                  "--result=./_Reports/JustUnitTestReport.xml"
                  Path.getFullName "_Binaries/AltCover.Api.Tests/Debug+AnyCPU/net472/AltCover.Api.Tests.dll"
                  Path.getFullName "_Binaries/AltCover.Tests/Debug+AnyCPU/net472/AltCover.Tests.dll"
                  Path.getFullName
                      "_Binaries/AltCover.Visualizer.Tests/Debug+AnyCPU/net472/AltCover.Tests.Visualizer.dll"
                  Path.getFullName
                      "_Binaries/AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net472/AltCover.ValidateGendarmeEmulation.dll" ]

            Actions.Run(nunitConsole, ".", baseArgs) "Main NUnit failed"

            let recArgs =
                [ "--noheader"
                  "--work=."
                  "--result=./_Reports/RecorderUnitTestReport.xml"
                  Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472/AltCover.Recorder.Tests.dll" ]

            Actions.Run(nunitConsole, ".", recArgs) "Recorder NUnit failed"

            let rec2Args =
                [ "--noheader"
                  "--work=."
                  "--result=./_Reports/Recorder2UnitTestReport.xml"
                  Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net20/AltCover.Recorder.Tests.dll" ]

            Actions.Run(nunitConsole, ".", rec2Args) "Recorder NUnit failed"

        with
        | x ->
            printfn "%A" x
            reraise ())

_Target
    "BuildForUnitTestDotNet"
    (fun _ ->
        let withTagDebug (p: MSBuildParams) =
            { p with
                  Properties =
                      ("AltCoverTag", "UnitTestDotNet_")
                      :: ("Configuration", "Debug") :: p.Properties
                  DoRestore = true }

        let msbuildDebug = doMSBuild withTagDebug
        msbuildDebug MSBuildPath "./AltCover.Recorder.Tests/AltCover.Recorder.Tests.fsproj"
        msbuildDebug MSBuildPath "./AltCover.Recorder2.Tests/AltCover.Recorder2.Tests.fsproj"

        let buildIt =
            DotNet.build
                (fun p ->
                    { p.WithCommon dotnetOptions with
                          Configuration = DotNet.BuildConfiguration.Debug
                          Framework = Some "net6.0" }
                    |> (buildWithCLITaggedArguments "UnitTestDotNet"))

        !!(@"./*Test*/*Tests.fsproj")
        |> Seq.filter (fun s -> s.Contains("Recorder") |> not) // net20
        |> Seq.iter buildIt

        !!(@"./*.Valid*/*Valid*.fsproj")
        |> Seq.iter buildIt)

_Target
    "UnitTestDotNet"
    (fun _ ->
        Directory.ensure "./_Reports"

        let testIt =
            DotNet.test
                (fun p ->
                    { p.WithCommon dotnetOptions with
                          Configuration = DotNet.BuildConfiguration.Debug
                          Framework = Some "net6.0"
                          NoBuild = true }
                    |> (testWithCLITaggedArguments "UnitTestDotNet"))

        try
            [ Path.getFullName "./AltCover.Expecto.Tests/AltCover.Expecto.Tests.fsproj"
              Path.getFullName "./AltCover.Api.Tests/AltCover.Api.Tests.fsproj"
              //Path.getFullName "./AltCover.Monitor.Tests/AltCover.Monitor.Tests.fsproj"
              Path.getFullName "./AltCover.Recorder.Tests/AltCover.Recorder.Tests.fsproj"
              Path.getFullName "./AltCover.Recorder2.Tests/AltCover.Recorder2.Tests.fsproj"
              Path.getFullName "./AltCover.ValidateGendarmeEmulation/AltCover.ValidateGendarmeEmulation.fsproj"
              Path.getFullName "./AltCover.Visualizer.Tests/AltCover.Visualizer.Tests.fsproj" ] // project
            |> Seq.iter testIt
        with
        | x ->
            printfn "%A" x
            reraise ())

_Target
    "BuildForCoverlet"
    (fun _ ->
        let withTagDebug (p: MSBuildParams) =
            { p with
                  Properties =
                      ("AltCoverTag", "Coverlet_")
                      :: ("Configuration", "Debug") :: p.Properties
                  DoRestore = true }

        let msbuildDebug = doMSBuild withTagDebug

        msbuildDebug MSBuildPath "./AltCover.Recorder.Tests/AltCover.Recorder.Tests.fsproj"
        msbuildDebug MSBuildPath "./AltCover.Recorder2.Tests/AltCover.Recorder2.Tests.fsproj"

        [ Path.getFullName "./AltCover.Expecto.Tests/AltCover.Expecto.Tests.fsproj"
          Path.getFullName "./AltCover.Api.Tests/AltCover.Api.Tests.fsproj"
          //Path.getFullName "./AltCover.Monitor.Tests/AltCover.Monitor.Tests.fsproj"
          Path.getFullName "./AltCover.ValidateGendarmeEmulation/AltCover.ValidateGendarmeEmulation.fsproj"
          Path.getFullName "./AltCover.Visualizer.Tests/AltCover.Visualizer.Tests.fsproj" ] // project
        |> Seq.iter (
            DotNet.build
                (fun p ->
                    { p.WithCommon dotnetOptions with
                          Configuration = DotNet.BuildConfiguration.Debug
                          Framework = Some "net6.0" }
                    |> (buildWithCLITaggedArguments "Coverlet"))
        ))

_Target
    "UnitTestDotNetWithCoverlet"
    (fun _ ->
        Directory.ensure "./_Reports"

        try
            let l =
                [ Path.getFullName "./AltCover.Expecto.Tests/AltCover.Expecto.Tests.fsproj"
                  Path.getFullName "./AltCover.Api.Tests/AltCover.Api.Tests.fsproj"
                  //Path.getFullName "./AltCover.Monitor.Tests/AltCover.Monitor.Tests.fsproj"
                  Path.getFullName "./AltCover.Recorder.Tests/AltCover.Recorder.Tests.fsproj"
                  Path.getFullName "./AltCover.Recorder2.Tests/AltCover.Recorder2.Tests.fsproj"
                  Path.getFullName "./AltCover.Visualizer.Tests/AltCover.Visualizer.Tests.fsproj"
                  Path.getFullName "./AltCover.ValidateGendarmeEmulation/AltCover.ValidateGendarmeEmulation.fsproj" ] // project

            let xml =
                l
                |> Seq.fold
                    (fun l f ->
                        let here = Path.GetDirectoryName f
                        let name = here |> Path.GetFileName

                        let report =
                            Path.Combine(Path.getFullName "./_Reports", "Coverlet_" + name)

                        let tr = report @@ "TestResults"
                        Directory.ensure tr
                        Shell.cleanDir tr

                        try
                            f
                            |> DotNet.test (coverletTaggedTestOptions tr "Coverlet")
                        with
                        | x -> eprintf "%A" x

                        // Can't seem to get this any other way
                        let ocovxml =
                            (!!(tr @@ "*/coverage.opencover.xml")
                             |> Seq.tryHead)
                            |> Option.map Path.getFullName

                        match ocovxml with
                        | None -> l
                        | Some covxml ->
                            let doc = covxml |> XDocument.Load

                            let key =
                                doc.Descendants(XName.Get "Name")
                                |> Seq.filter (fun x -> x.Value = "System.Void AltCover.CommandLine/Format::.ctor()")
                                |> Seq.toList

                            key |> List.iter (fun x -> x.Parent.Remove())

                            let target =
                                (Path.getFullName "./_Reports")
                                @@ ((Path.GetFileNameWithoutExtension f)
                                    + ".coverlet.xml")

                            doc.Save target

                            // Shell.copyFile target covxml
                            target :: l)
                    []

            ReportGenerator.generateReports
                (fun p ->
                    { p with
                          ToolType = ToolType.CreateLocalTool()
                          ReportTypes =
                              [ ReportGenerator.ReportType.Html
                                ReportGenerator.ReportType.XmlSummary ]
                          TargetDir = "_Reports/_UnitTestWithCoverlet" })
                (xml
                 |> List.filter (fun p -> not <| p.Contains("Visualizer")))

            ReportGenerator.generateReports
                (fun p ->
                    { p with
                          ToolType = ToolType.CreateLocalTool()
                          ReportTypes = [ ReportGenerator.ReportType.Html ]
                          TargetDir = "_Reports/_VisualizerWithCoverlet" })
                (xml
                 |> List.filter (fun p -> p.Contains("Visualizer")))

            uncovered @"_Reports/_UnitTestWithCoverl*/Summary.xml"
            |> List.map fst
            |> printfn "%A uncovered lines"
        with
        | x ->
            printfn "%A" x
            reraise ())

_Target
    "UnitTestWithOpenCover"
    (fun _ ->
        Directory.ensure "./_Reports/_UnitTestWithOpenCover"

        let testFiles =
            [ Path.getFullName "_Binaries/AltCover.Api.Tests/Debug+AnyCPU/net472/AltCover.Api.Tests.dll"
              //Path.getFullName "_Binaries/AltCover.Expecto.Tests/Debug+AnyCPU/net472/AltCover.Expecto.Tests.dll"
              //Path.getFullName "_Binaries/AltCover.Monitor.Tests/Debug+AnyCPU/net472/AltCover.Monitor.Tests.dll"
              //Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472/AltCover.Recorder.Tests.dll"
              //Path.getFullName "_Binaries/AltCover.Recorder2.Tests/Debug+AnyCPU/net472/AltCover.Recorder2.Tests.dll"
              Path.getFullName "_Binaries/AltCover.Tests/Debug+AnyCPU/net472/AltCover.Tests.dll"
              //Path.getFullName "_Binaries/AltCover.Tests.Visualizer/Debug+AnyCPU/net472/AltCover.Tests.Visualizer.dll"
              Path.getFullName
                  "_Binaries/AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net472/AltCover.ValidateGendarmeEmulation.dll" ]

        let Recorder4Files =
            !!(@"_Binaries/*Tests/Debug+AnyCPU/net472/*Recorder.Tests.dll")

        let RecorderFiles =
            !!(@"_Binaries/*Tests/Debug+AnyCPU/net20/AltCover*Test*.dll")

        let VisualizerFiles =
            !!(@"_Binaries/AltCover.Visualizer.Tests/Debug+AnyCPU/net472/AltCover.Test*.dll")

        let coverage =
            Path.getFullName "_Reports/UnitTestWithOpenCover.xml"

        let scoverage =
            Path.getFullName "_Reports/RecorderTestWithOpenCover.xml"

        let s4coverage =
            Path.getFullName "_Reports/Recorder4TestWithOpenCover.xml"

        let vcoverage =
            Path.getFullName "_Reports/VisualizerTestWithOpenCover.xml"

        try
            OpenCover.run
                (fun p ->
                    { p with
                          WorkingDir = "."
                          ExePath = openCoverConsole
                          TestRunnerExePath = nunitConsole // OK, not on Linux
                          Filter =
                              "+[AltCover]* +[AltCover.*]* -[*]Microsoft.* -[*]System.* -[Sample*]* -[*]ICSharpCode.* -[FSharp.Core]* -[Gendarme.*]* -[xunit.*]* -[AltCover.*]*StartupCode*SolutionRoot"
                          MergeByHash = true
                          ReturnTargetCode = Fake.DotNet.Testing.OpenCover.ReturnTargetCodeType.Yes
                          OptionalArguments = "-excludebyattribute:*ExcludeFromCodeCoverageAttribute;*ProgIdAttribute"
                          Register = OpenCover.RegisterType.Path64
                          Output = vcoverage
                          TimeOut = TimeSpan(0, 10, 0) })
                (String.Join(" ", VisualizerFiles)
                 + " --result=./_Reports/VisualizerTestWithOpenCoverReport.xml")

            OpenCover.run
                (fun p ->
                    { p with
                          WorkingDir = "."
                          ExePath = openCoverConsole
                          TestRunnerExePath = nunitConsole // OK, not on Linux
                          Filter =
                              "+[AltCover]* +[AltCover.*]* -[*]Microsoft.* -[*]System.* -[Sample*]* -[*]ICSharpCode.* -[FSharp.Core]* -[Gendarme.*]* -[xunit.*]* -[AltCover.*]*StartupCode*SolutionRoot"
                          MergeByHash = true
                          ReturnTargetCode = Fake.DotNet.Testing.OpenCover.ReturnTargetCodeType.Yes
                          OptionalArguments = "-excludebyattribute:*ExcludeFromCodeCoverageAttribute;*ProgIdAttribute"
                          Register = OpenCover.RegisterType.Path64
                          Output = coverage
                          TimeOut = TimeSpan(0, 10, 0) })
                (String.Join(" ", testFiles)
                 + " --result=./_Reports/UnitTestWithOpenCoverReport.xml")

            OpenCover.run
                (fun p ->
                    { p with
                          WorkingDir = "."
                          ExePath = openCoverConsole
                          TestRunnerExePath = nunitConsole // OK, not on Linux
                          Filter =
                              "+[AltCover.Recorder]* +[AltCover.Recorder.Tests]* -[*]ICSharpCode.* -[*]System.* -[AltCover.*]*StartupCode*SolutionRoot"
                          MergeByHash = true
                          ReturnTargetCode = Fake.DotNet.Testing.OpenCover.ReturnTargetCodeType.Yes
                          OptionalArguments = "-excludebyattribute:*ExcludeFromCodeCoverageAttribute;*ProgIdAttribute"
                          Register = OpenCover.RegisterType.RegisterUser // Path64 doesn't work on my machine
                          Output = scoverage })
                (String.Join(" ", RecorderFiles)
                 + " --result=./_Reports/RecorderTestWithOpenCoverReport.xml")

            OpenCover.run
                (fun p ->
                    { p with
                          WorkingDir = "."
                          ExePath = openCoverConsole
                          TestRunnerExePath = nunitConsole // OK, not on Linux
                          Filter =
                              "+[AltCover.Recorder]* +[AltCover.Recorder.Tests]* -[*]ICSharpCode.* -[*]System.* -[AltCover.*]*StartupCode*SolutionRoot"
                          MergeByHash = true
                          ReturnTargetCode = Fake.DotNet.Testing.OpenCover.ReturnTargetCodeType.Yes
                          OptionalArguments = "-excludebyattribute:*ExcludeFromCodeCoverageAttribute;*ProgIdAttribute"
                          Register = OpenCover.RegisterType.Path64
                          Output = s4coverage })
                (String.Join(" ", Recorder4Files)
                 + " --result=./_Reports/RecorderTest4WithOpenCoverReport.xml")

        with
        | x ->
            printfn "%A" x
            reraise ()

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_UnitTestWithOpenCover" })
            [ coverage; scoverage; s4coverage ]

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_VisualizerTestsWithOpenCover" })
            [ vcoverage ]

        uncovered @"_Reports/_UnitTestWithOpenCove*/Summary.xml"
        |> List.map fst
        |> printfn "%A uncovered lines")

// Hybrid (Self) Tests

_Target
    "UnitTestWithAltCover"
    (fun _ ->
        Directory.ensure "./_Reports/_UnitTestWithAltCover"

        // Tools
        let keyfile = Path.getFullName "Build/SelfTest.snk"

        let shadowkeyfile =
            Path.getFullName "Build/Infrastructure.snk"

        let reports = Path.getFullName "./_Reports"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/net472/AltCover.exe"

        let sn =
            "sn" |> Fake.Core.ProcessUtils.tryFindFileOnPath

        // net4x tests
        let testDirectory =
            Path.getFullName "_Binaries/AltCover.Tests/Debug+AnyCPU/net472"

        let weakDir =
            Path.getFullName "_Binaries/AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net472"

        let Recorder4Dir =
            Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472"

        let apiDir =
            Path.getFullName "_Binaries/AltCover.Api.Tests/Debug+AnyCPU/net472"

        // TODO/maybes
        //let monitorDir = Path.getFullName "_Binaries/AltCover.Monitor.Tests/Debug+AnyCPU/net472"

        // let visDir =
        //       Path.getFullName "_Binaries/AltCover.Tests.Visualizer/Debug+AnyCPU/net472/AltCover.Tests.Visualizer.dll"

        let altReport = reports @@ "UnitTestWithAltCover.xml"

        printfn "Instrument the net4x code"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = altReport
                      InputDirectories =
                          [| "."
                             weakDir
                             Recorder4Dir
                             apiDir (*; visDir ; monitorDir*)  |]
                      OutputDirectories =
                          [| "./__UnitTestWithAltCover"
                             weakDir
                             @@ "__ValidateGendarmeEmulationWithAltCover"
                             Recorder4Dir @@ "__RecorderTestWithAltCover"
                             apiDir
                             @@ "__ApiTestWithAltCover" (*visDir @@ "__VisualizerTestWithAltCover"; monitorDir @@ "__MonitorTestWithAltCover"*)  |]
                      StrongNameKey = keyfile
                      ReportFormat = "NCover"
                      InPlace = false
                      Save = false }
                |> AltCoverFilterX
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = frameworkAltcover
              WorkingDirectory = testDirectory }
        |> AltCoverCommand.run

        if sn |> Option.isSome then
            Actions.Run
                (sn |> Option.get,
                 testDirectory,
                 [ "-vf"
                   "./__UnitTestWithAltCover/AltCover.Recorder.g.dll" ])
                "Recorder assembly strong-name verified OK"

        printfn "Unit test the instrumented net4x code"

        try
            let baseArgs =
                [ "--noheader"
                  "--work=."
                  "--result=./_Reports/UnitTestWithAltCoverReport.xml"
                  Path.getFullName
                      "_Binaries/AltCover.Tests/Debug+AnyCPU/net472/__UnitTestWithAltCover/AltCover.Tests.dll"
                  Path.getFullName
                      "_Binaries/AltCover.Api.Tests/Debug+AnyCPU/net472/__ApiTestWithAltCover/AltCover.Api.Tests.dll"
                  Path.getFullName
                      "_Binaries/AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net472/__ValidateGendarmeEmulationWithAltCover/AltCover.ValidateGendarmeEmulation.dll"
                  //Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472/__RecorderTestWithAltCover/AltCover.Recorder.Tests.dll"
                  Path.getFullName "_Binaries/AltCover.Tests/Debug+AnyCPU/net472/__UnitTestWithAltCover/Sample2.dll" ]

            Actions.Run(nunitConsole, ".", baseArgs) "Main NUnit failed"
        with
        | x ->
            printfn "UnitTestWithAltCover caught %A" x
            reraise ()

        printfn "Instrument the net20 Recorder tests"

        let RecorderDir =
            Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net20"

        let RecorderReport =
            reports @@ "RecorderTestWithAltCover.xml"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = RecorderReport
                      OutputDirectories = [| "./__RecorderTestWithAltCover" |]
                      StrongNameKey = shadowkeyfile
                      ReportFormat = "NCover"
                      InPlace = false
                      Save = false }
                |> AltCoverFilter
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = frameworkAltcover
              WorkingDirectory = RecorderDir }
        |> AltCoverCommand.run

        printfn "Execute the net20 Recorder tests"

        //        !!("_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net20/__RecorderTestWithAltCover/Alt*.Test*.dll")
//        |> NUnitRetry
//            (fun p ->
//                { p with
//                      ToolPath = nunitConsole
//                      WorkingDir = "." })
//            "./_Reports/RecorderTestWithAltCoverReport.xml"

        let recArgs =
            [ "--noheader"
              "--work=."
              "--result=./_Reports/RecorderTestWithAltCoverReport.xml"
              Path.getFullName
                  "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net20/__RecorderTestWithAltCover/AltCover.Recorder.Tests.dll" ]

        Actions.Run(nunitConsole, ".", recArgs) "Recorder net20 NUnit failed"

        printfn "Instrument the net472 Recorder tests"

        let Recorder472Dir =
            Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472"

        let Recorder472Report =
            reports @@ "Recorder472TestWithAltCover.xml"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = Recorder472Report
                      OutputDirectories = [| "./__Recorder472TestWithAltCover" |]
                      StrongNameKey = shadowkeyfile
                      ReportFormat = "NCover"
                      InPlace = false
                      Save = false }
                |> AltCoverFilter
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = frameworkAltcover
              WorkingDirectory = Recorder472Dir }
        |> AltCoverCommand.run

        printfn "Execute the net472 Recorder tests"

        let rec4Args =
            [ "--noheader"
              "--work=."
              "--result=./_Reports/Recorder4TestWithAltCoverReport.xml"
              Path.getFullName
                  "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472/__Recorder472TestWithAltCover/AltCover.Recorder.Tests.dll" ]

        Actions.Run(nunitConsole, ".", rec4Args) "Recorder net472 NUnit failed"

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_UnitTestWithAltCover" })
            [ altReport
              RecorderReport
              Recorder472Report ]

        uncovered @"_Reports/_UnitTestWithAltCover/Summary.xml"
        |> List.map fst
        |> printfn "%A uncovered lines")

_Target
    "UnitTestWithAltCoverRunner"
    (fun _ ->
        Directory.ensure "./_Reports/_UnitTestWithAltCoverRunner"

        // Tools
        let keyfile = Path.getFullName "Build/SelfTest.snk"

        let shadowkeyfile =
            Path.getFullName "Build/Infrastructure.snk"

        let reports = Path.getFullName "./_Reports"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/net472/AltCover.exe"

        // Only use
        let baseFilter = AltCoverFilterTypeSafe

        let tests =
            [ (Path.getFullName "_Binaries/AltCover.Tests/Debug+AnyCPU/net472",  // test directory
               "./__UnitTestWithAltCoverRunner",  // relative output
               "UnitTestWithAltCoverRunner.xml",  // coverage report
               "./_Reports/UnitTestWithAltCoverRunnerReport.xml",  // relative nunit reporting
               [ Path.getFullName // test assemblies
                     "_Binaries/AltCover.Tests/Debug+AnyCPU/net472/__UnitTestWithAltCoverRunner/AltCover.Tests.dll" ],
               baseFilter,
               keyfile)
              (Path.getFullName "_Binaries/AltCover.Api.Tests/Debug+AnyCPU/net472",  // test directory
               "./__ApiTestWithAltCoverRunner",  // relative output
               "ApiTestWithAltCoverRunner.xml",  // coverage report
               "./_Reports/ApiTestWithAltCoverRunnerReport.xml",  // relative nunit reporting
               [ Path.getFullName // test assemblies
                     "_Binaries/AltCover.Api.Tests/Debug+AnyCPU/net472/__ApiTestWithAltCoverRunner/AltCover.Api.Tests.dll" ],
               baseFilter,
               keyfile)
              // (
              //   Path.getFullName "_Binaries/AltCover.Monitor.Tests/Debug+AnyCPU/net472", // test directory
              //   "./__MonitorTestWithAltCoverRunner", // relative output
              //   "MonitorTestWithAltCoverRunner.xml", // coverage report
              //   "./_Reports/MonitorTestWithAltCoverRunnerReport.xml", // relative nunit reporting
              //   [ Path.getFullName // test assemblies
              //       "_Binaries/AltCover.Monitor.Tests/Debug+AnyCPU/net472/__MonitorTestWithAltCoverRunner/AltCover.Monitor.Tests.dll" ],
              //   baseFilter,
              //   keyfile
              // )
              (Path.getFullName "_Binaries/AltCover.Visualizer.Tests/Debug+AnyCPU/net472",  // test directory
               "./__VisualizerTestWithAltCoverRunner",  // relative output
               "VisualizerTestWithAltCoverRunner.xml",  // coverage report
               "./_Reports/VisualizerTestWithAltCoverRunnerReport.xml",  // relative nunit reporting
               [ Path.getFullName // test assemblies
                     "_Binaries/AltCover.Visualizer.Tests/Debug+AnyCPU/net472/__VisualizerTestWithAltCoverRunner/AltCover.Tests.Visualizer.dll" ],
               baseFilter,
               keyfile)
              (Path.getFullName "_Binaries/AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net472",
               "./__ValidateGendarmeEmulationWithAltCoverRunner",
               "ValidateGendarmeEmulationWithAltCoverRunner.xml",
               "./_Reports/ValidateGendarmeEmulationWithAltCoverRunnerReport.xml",
               [ Path.getFullName
                     "_Binaries/AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net472/__ValidateGendarmeEmulationWithAltCoverRunner/AltCover.ValidateGendarmeEmulation.dll" ],
               // only use // (* >> (fun x ->  { x with AssemblyExcludeFilter = TypeSafe.Filters [] }) *),
               AltCoverFilterXTypeSafe,
               keyfile)
              (Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472",
               "./__RecorderTestWithAltCoverRunner",
               "RecorderTestWithAltCoverRunner.xml",
               "./_Reports/RecorderTestWithAltCoverRunnerReport.xml",
               [ Path.getFullName
                     "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net472/__RecorderTestWithAltCoverRunner/AltCover.Recorder.Tests.dll" ],
               baseFilter,
               shadowkeyfile)
              (Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net20",
               "./__RecorderTest2WithAltCoverRunner",
               "RecorderTest2WithAltCoverRunner.xml",
               "./_Reports/RecorderTest2WithAltCoverRunnerReport.xml",
               [ Path.getFullName
                     "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net20/__RecorderTest2WithAltCoverRunner/AltCover.Recorder.Tests.dll" ],
               baseFilter
               >> (fun p ->
                   { p with
                         AttributeFilter =
                             [ TypeSafe.Raw "EntryPoint" ]
                             |> p.AttributeFilter.Join }),
               shadowkeyfile) ]

        tests
        |> List.iter
            (fun (testDirectory, outputDirectory, coverageReport, nunitReport, nunitAssemblies, filter, signingKey) ->
                let altReport = reports @@ coverageReport
                printfn "Instrument the code %s" testDirectory

                let prep =
                    AltCover.PrepareOptions.TypeSafe(
                        { TypeSafe.PrepareOptions.Create() with
                              Report = TypeSafe.FilePath altReport
                              OutputDirectories = TypeSafe.DirectoryPaths [| TypeSafe.DirectoryPath outputDirectory |]
                              StrongNameKey = TypeSafe.FilePath signingKey
                              SingleVisit = TypeSafe.Set
                              InPlace = TypeSafe.Clear
                              Save = TypeSafe.Clear }
                        |> filter
                    )
                    |> AltCoverCommand.Prepare

                { AltCoverCommand.Options.Create prep with
                      ToolPath = altcover
                      ToolType = frameworkAltcover
                      WorkingDirectory = testDirectory }
                |> AltCoverCommand.run

                printfn "Unit test the instrumented code %s" outputDirectory

                let nunitparams =
                    { NUnit3Defaults with
                          ToolPath = nunitConsole
                          WorkingDir = "."
                          ResultSpecs = [ nunitReport ] }

                let nunitcmd =
                    NUnit3.buildArgs nunitparams nunitAssemblies

                let collect =
                    AltCover.CollectOptions.TypeSafe
                        { TypeSafe.CollectOptions.Create() with
                              Executable = TypeSafe.FilePath nunitConsole
                              RecorderDirectory = TypeSafe.DirectoryPath(testDirectory @@ outputDirectory)
                              CommandLine =
                                  nunitcmd
                                  |> AltCoverCommand.splitCommandLine
                                  |> Seq.map TypeSafe.CommandArgument
                                  |> TypeSafe.CommandArguments }
                    |> AltCoverCommand.Collect

                let command =
                    { AltCoverCommand.Options.Create collect with
                          ToolPath = altcover
                          ToolType = frameworkAltcover
                          WorkingDirectory = "." }

                let nUnitRetry2 () =
                    let rec doNUnitRetry2 depth =
                        try
                            if File.Exists nunitReport then
                                File.Delete nunitReport

                            AltCoverCommand.run command
                        with
                        | x ->
                            printfn "%A" x

                            if depth > 2 then
                                printfn "Recursion limited"
                                reraise ()

                            if File.Exists nunitReport then
                                let xml =
                                    "./Build/NuGet.csproj"
                                    |> Path.getFullName
                                    |> XDocument.Load

                                let summary =
                                    xml.Descendants(XName.Get "test-run") |> Seq.head

                                let failcount =
                                    summary.Attribute(XName.Get "failed").Value

                                if failcount = "0" then
                                    doNUnitRetry2 (depth + 1)
                                else
                                    printfn "Actual failures %A" failcount
                                    reraise ()
                            else
                                printfn "Report not found"
                                reraise ()

                    doNUnitRetry2 0

                nUnitRetry2 ())

        let xmlreports =
            tests
            |> List.map (fun (_, _, report, _, _, _, _) -> reports @@ report)
            |> List.filter (fun r -> not <| r.Contains("Visualizer"))

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_UnitTestWithAltCoverRunner" })
            xmlreports

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes = [ ReportGenerator.ReportType.Html ]
                      TargetDir = "_Reports/_VisualizerTestsWithAltCoverRunner" })
            (tests
             |> List.map (fun (_, _, report, _, _, _, _) -> reports @@ report)
             |> List.filter (fun r -> r.Contains("Visualizer")))

        uncovered @"_Reports/_UnitTestWithAltCoverRunner/Summary.xml"
        |> List.map fst
        |> printfn "%A uncovered lines")

_Target
    "UnitTestWithAltCoverCore"
    (fun _ ->
        Directory.ensure "./_Reports/_UnitTestWithAltCoverCore"
        let keyfile = Path.getFullName "Build/SelfTest.snk"
        let reports = Path.getFullName "./_Reports"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"

        let tests = // TODo monitor!not, Visualizer
            [ (Path.getFullName "_Binaries/AltCover.Expecto.Tests/Debug+AnyCPU/net6.0",  // testDirectory
               Path.getFullName "_Binaries/UnitTestWithAltCoverCore_AltCover.Expecto.Tests/Debug+AnyCPU/net6.0",  // output
               reports @@ "UnitTestWithAltCoverCore.xml",  // report
               "AltCover.Expecto.Tests.fsproj",  // project
               Path.getFullName "AltCover.Expecto.Tests") // workingDirectory
              (Path.getFullName "_Binaries/AltCover.Recorder.Tests/Debug+AnyCPU/net6.0",
               Path.getFullName "_Binaries/UnitTestWithAltCoverCore_AltCover.Recorder.Tests/Debug+AnyCPU/net6.0",
               reports @@ "RecorderTestWithAltCoverCore.xml",
               "AltCover.Recorder.Tests.fsproj",
               Path.getFullName "AltCover.Recorder.Tests")
              (Path.getFullName "_Binaries/AltCover.Recorder2.Tests/Debug+AnyCPU/net6.0",
               Path.getFullName "_Binaries/UnitTestWithAltCoverCore_AltCover.Recorder2.Tests/Debug+AnyCPU/net6.0",
               reports @@ "Recorder2TestWithAltCoverCore.xml",
               "AltCover.Recorder2.Tests.fsproj",
               Path.getFullName "AltCover.Recorder2.Tests")
              (Path.getFullName "_Binaries/AltCover.Api.Tests/Debug+AnyCPU/net6.0",  // testDirectory
               Path.getFullName "_Binaries/UnitTestWithAltCoverCore_AltCover.Api.Tests/Debug+AnyCPU/net6.0",  // output
               reports @@ "ApiUnitTestWithAltCoverCore.xml",  // report
               "AltCover.Api.Tests.fsproj",  // project
               Path.getFullName "AltCover.Api.Tests") // workingDirectory
              (Path.getFullName "_Binaries/AltCover.Monitor.Tests/Debug+AnyCPU/net6.0",  // testDirectory
               Path.getFullName "_Binaries/UnitTestWithAltCoverCore_AltCover.Monitor.Tests/Debug+AnyCPU/net6.0",  // output
               reports @@ "MonitorTestWithAltCoverCore.xml",  // report
               "AltCover.Monitor.Tests.fsproj",  // project
               Path.getFullName "AltCover.Monitor.Tests") // workingDirectory
              (Path.getFullName "_Binaries/AltCover.Visualizer.Tests/Debug+AnyCPU/net6.0",  // testDirectory
               Path.getFullName "_Binaries/UnitTestWithAltCoverCore_AltCover.Visualizer.Tests/Debug+AnyCPU/net6.0",  // output
               reports
               @@ "VisualizerUnitTestWithAltCoverCore.xml",  // report
               "AltCover.Visualizer.Tests.fsproj",  // project
               Path.getFullName "AltCover.Visualizer.Tests") // workingDirectory
              (Path.getFullName "_Binaries/AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net6.0",  // testDirectory
               Path.getFullName
                   "_Binaries/UnitTestWithAltCoverCore_AltCover.ValidateGendarmeEmulation/Debug+AnyCPU/net6.0",  // output
               reports
               @@ "ValidateGendarmeEmulationUnitTestWithAltCoverCore.xml",  // report
               "AltCover.ValidateGendarmeEmulation.fsproj",  // project
               Path.getFullName "AltCover.ValidateGendarmeEmulation") ] // workingDirectory

        tests
        |> List.iter
            (fun (testDirectory, output, report, project, workingDirectory) ->

                printfn "Instrument the code %s" testDirectory

                let prep =
                    AltCover.PrepareOptions.Primitive(
                        { Primitive.PrepareOptions.Create() with
                              TypeFilter = [ "SolutionRoot"; "Expecto" ]
                              Report = report
                              OutputDirectories = [| output |]
                              StrongNameKey = keyfile
                              ReportFormat = "NCover"
                              Defer = true
                              InPlace = false
                              Save = false }
                        |> AltCoverFilter
                    )
                    |> AltCoverCommand.Prepare

                { AltCoverCommand.Options.Create prep with
                      ToolPath = altcover
                      ToolType = dotnetAltcover
                      WorkingDirectory = testDirectory }
                |> AltCoverCommand.run

                printfn "Unit test the instrumented code %s" project

                // AltCoverTag =
                try
                    project
                    |> DotNet.test
                        (fun p ->
                            { p.WithCommon(withWorkingDirectoryVM workingDirectory) with
                                  Configuration = DotNet.BuildConfiguration.Debug
                                  Framework = Some "net6.0"
                                  NoBuild = true }
                            |> (testWithCLITaggedArguments "UnitTestWithAltCoverCore")
                            |> (collectorTestOptions (project |> Path.GetFileNameWithoutExtension)))
                with
                | x ->
                    printfn "%A" x
                    reraise ())

        let xmlreports =
            tests
            |> List.map (fun (_, _, report, _, _) -> report)
            |> List.filter (fun f -> f.Contains("Visualizer") |> not)

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_UnitTestWithAltCoverCore" })
            xmlreports

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_VisualizerWithAltCoverCore" })
            (tests
             |> List.map (fun (_, _, report, _, _) -> report)
             |> List.filter (fun f -> f.Contains("Visualizer")))

        uncovered @"_Reports/_UnitTestWithAltCoverCore/Summary.xml"
        |> List.map fst
        |> printfn "%A uncovered lines")

_Target
    "UnitTestWithAltCoverCoreRunner"
    (fun _ ->
        Directory.ensure "./_Reports/_UnitTestWithAltCoverCoreRunner"
        let keyfile = Path.getFullName "Build/SelfTest.snk"
        let reports = Path.getFullName "./_Reports"

        let tests =
            [ (reports @@ "UnitTestWithAltCoverCoreRunner.xml",  // report
               Path.getFullName "./AltCover.Expecto.Tests/AltCover.Expecto.Tests.fsproj")
              (reports @@ "ApiTestWithAltCoverCoreRunner.xml",  // report
               Path.getFullName "./AltCover.Api.Tests/AltCover.Api.Tests.fsproj")
              (reports @@ "MonitorTestWithAltCoverCoreRunner.xml",  // report
               Path.getFullName "./AltCover.Monitor.Tests/AltCover.Monitor.Tests.fsproj")
              (reports
               @@ "RecorderTestWithAltCoverCoreRunner.xml",
               Path.getFullName "./AltCover.Recorder.Tests/AltCover.Recorder.Tests.fsproj")
              (reports
               @@ "Recorder2TestWithAltCoverCoreRunner.xml",
               Path.getFullName "./AltCover.Recorder2.Tests/AltCover.Recorder2.Tests.fsproj")
              (reports
               @@ "VisualizerTestWithAltCoverCoreRunner.xml",
               Path.getFullName "./AltCover.Visualizer.Tests/AltCover.Visualizer.Tests.fsproj")
              (reports
               @@ "ValidateGendarmeEmulationUnitTestWithAltCoverCoreRunner.xml",  // report
               Path.getFullName "./AltCover.ValidateGendarmeEmulation/AltCover.ValidateGendarmeEmulation.fsproj") ] // project

        try
            tests
            |> List.iter
                (fun (report, testproject) ->
                    let dir = testproject |> Path.GetDirectoryName
                    let proj = testproject |> Path.GetFileName
                    let name = dir |> Path.GetFileName
                    let root = dir |> Path.GetDirectoryName
                    let testdir = root @@ ("__" + name)
                    Directory.ensure testdir
                    Shell.cleanDir testdir

                    Shell.copy testdir (!!(dir @@ "*.*"))

                    if (Directory.Exists(dir @@ "Results")) then
                        Directory.ensure (testdir @@ "Results")
                        Shell.copyDir (testdir @@ "Results") (dir @@ "Results") (fun _ -> true)

                    let config =
                        XDocument.Load "./Build/NuGet.config.dotnettest"

                    let repo =
                        config.Descendants(XName.Get("add")) |> Seq.head

                    repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
                    config.Save(testdir @@ "NuGet.config")

                    let fsproj = XDocument.Load testproject

                    let pack =
                        fsproj.Descendants(XName.Get("PackageReference"))
                        |> Seq.head

                    let inject =
                        XElement(
                            XName.Get "PackageReference",
                            XAttribute(XName.Get "Include", "altcover"),
                            XAttribute(XName.Get "Version", Version.Value)
                        )

                    pack.AddBeforeSelf inject

                    let newproj = testdir @@ proj
                    fsproj.Save newproj

                    DotNet.restore
                        (fun o ->
                            let tmp =
                                o.WithCommon(withWorkingDirectoryVM testdir)

                            let mparams =
                                { tmp.MSBuildParams with
                                      Properties = tmp.MSBuildParams.Properties }

                            { tmp with MSBuildParams = mparams })
                        proj

                    let prep =
                        AltCover.PrepareOptions.Primitive(
                            { Primitive.PrepareOptions.Create() with
                                  Report = report
                                  TypeFilter = [ "SolutionRoot"; "Expecto" ]
                                  VisibleBranches = true
                                  StrongNameKey = keyfile
                                  SingleVisit = true }
                            |> AltCoverFilter
                        )

                    let coll =
                        AltCover.CollectOptions.Primitive
                        <| Primitive.CollectOptions.Create()

                    if proj.Contains("Recorder") then
                        doMSBuild
                            (withDebug
                             >> fun p ->
                                 { p with
                                       Properties =
                                           ("AltCoverTag", "UnitTestWithCoreRunner_")
                                           :: p.Properties
                                       Verbosity = Some MSBuildVerbosity.Minimal })
                            MSBuildPath
                            newproj

                    DotNet.test
                        (fun to' ->
                            { to'.WithCommon(withWorkingDirectoryVM testdir) with
                                  Framework = Some "net6.0"
                                  NoBuild = proj.Contains("Recorder") }
                                .WithAltCoverOptions
                                prep
                                coll
                                ForceTrue
                            |> (testWithCLITaggedArguments "UnitTestWithCoreRunner"))
                        proj)
        finally
            let folder =
                (nugetCache @@ "altcover") @@ Version.Value
            //printfn "Should clear %A" folder
            Shell.mkdir folder
            Actions.CleanDir folder

        let xmlreports =
            tests
            |> List.map
                (fun (report, _) ->
                    if File.Exists report then
                        report
                    else
                        report.Replace(".xml", ".net6.0.xml"))
            |> List.filter (fun f -> File.Exists f && f.Contains("Visualizer") |> not)

        let pester = Path.getFullName "_Reports/Pester.xml"

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_UnitTestWithAltCoverCoreRunner" })
            (pester :: xmlreports)

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes = [ ReportGenerator.ReportType.Html ]
                      TargetDir = "_Reports/_VisualizerTestWithAltCoverCoreRunner" })
            (tests
             |> List.map
                 (fun (report, _) ->
                     if File.Exists report then
                         report
                     else
                         report.Replace(".xml", ".net6.0.xml"))
             |> List.filter (fun f -> File.Exists f && f.Contains("Visualizer")))

        uncovered @"_Reports/_UnitTestWithAltCoverCoreRunner/Summary.xml"
        |> List.map fst
        |> printfn "%A uncovered lines")

// Pure OperationalTests

_Target "OperationalTest" ignore

_Target
    "FSharpTypes"
    (fun _ ->
        Directory.ensure "./_Reports"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("AltCoverFSharpTypes.xml")

        let binRoot =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472"

        let sampleRoot =
            Path.getFullName "_Binaries/Sample2/Debug+AnyCPU/net472"

        let instrumented = "__FSharpTypes"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      OutputDirectories = [| "./" + instrumented |]
                      AssemblyFilter = [ "Adapter"; "nunit"; "FSharp" ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = binRoot @@ "AltCover.exe"
              ToolType = frameworkAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        Actions.ValidateFSharpTypes simpleReport [])

_Target
    "FSharpTests"
    (fun _ ->
        Directory.ensure "./_Reports"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("AltCoverFSharpTests.xml")

        let sampleRoot =
            Path.getFullName "_Binaries/FSharpTests_Sample7/Debug+AnyCPU/netcoreapp2.1"

        // Test the --inplace operation
        Shell.cleanDir sampleRoot

        "Sample7.fsproj"
        |> DotNet.test
            (fun o ->
                { o.WithCommon(withWorkingDirectoryVM "Samples/Sample7") with
                      Configuration = DotNet.BuildConfiguration.Debug }
                |> (testWithCLITaggedArguments "FSharpTests"))

        // inplace instrument
        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      CallContext = [ "[Test]" ]
                      AssemblyFilter = [ "Adapter" ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      InPlace = true
                      ReportFormat = "OpenCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        printfn "Execute the instrumented tests"

        let sample7 =
            Path.getFullName "./Samples/Sample7/Sample7.fsproj"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine None sample7

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = sampleRoot
                      CommandLine = args @ [ "/p:AltCoverTag=FSharpTests_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = "Samples/Sample7" }
        |> AltCoverCommand.run

        let coverageDocument =
            XDocument.Load(XmlReader.Create(simpleReport))

        let refs =
            coverageDocument.Descendants(XName.Get("TrackedMethodRef"))
            |> Seq.toList

        Assert.That(refs |> Seq.length, Is.EqualTo 64, "ref count wrong")

        refs
        |> Seq.iter
            (fun tmr ->
                let spts = tmr.Parent.Parent.Parent

                let sptcount =
                    (spts.Descendants(XName.Get("SequencePoint"))
                     |> Seq.length)
                    + (spts.Descendants(XName.Get("BranchPoint"))
                       |> Seq.length)

                let tmrcount =
                    spts.Descendants(XName.Get("TrackedMethodRefs"))
                    |> Seq.length

                let name =
                    spts.Parent.Descendants(XName.Get("Name"))
                    |> Seq.head

                Assert.That(tmrcount, Is.LessThanOrEqualTo sptcount, name.Value)))

_Target
    "AsyncAwaitTests"
    (fun _ ->
        Directory.ensure "./_Reports"
        // Provoke this sub-issue : https://github.com/SteveGilham/altcover/issues/105#issuecomment-737203810
        // seen in 7.2.800, fixed in commit 93325bb645dcbfaf01b996fc99576ef4501f41b8
        "./_Intermediate/AltCover.Recorder/Debug+AnyCPU/net46/AltCover.Recorder.pdb"
        |> Path.getFullName
        |> File.delete

        "./_Intermediate/AltCover.Recorder/Release+AnyCPU/net46/AltCover.Recorder.pdb"
        |> Path.getFullName
        |> File.delete

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("AltCoverAsyncAwaitTests.xml")

        let sampleRoot =
            Path.getFullName "_Binaries/AsyncAwaitTests_Sample24/Debug+AnyCPU/netcoreapp3.1"

        // Test the --inplace operation
        Shell.cleanDir sampleRoot

        "Sample24.csproj"
        |> DotNet.test
            (fun o ->
                { o.WithCommon(withWorkingDirectoryVM "Samples/Sample24") with
                      Framework = Some "netcoreapp3.1"
                      Configuration = DotNet.BuildConfiguration.Debug }
                |> (testWithCLITaggedArguments "AsyncAwaitTests"))

        // instrument
        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      CallContext = [ "[Test]" ]
                      AssemblyFilter = [ "Adapter"; "nunit" ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      InPlace = true
                      ReportFormat = "OpenCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        printfn "Execute the instrumented tests"

        let sample24 =
            Path.getFullName "./Samples/Sample24/Sample24.csproj"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "netcoreapp3.1") sample24

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = sampleRoot
                      CommandLine = args @ [ "/p:AltCoverTag=AsyncAwaitTests_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = "Samples/Sample24" }
        |> AltCoverCommand.run

        let coverageDocument =
            XDocument.Load(XmlReader.Create(simpleReport))

        coverageDocument.Descendants(XName.Get("TrackedMethodRef"))
        |> Seq.toList
        |> Seq.iter
            (fun tmr ->
                let spts = tmr.Parent.Parent.Parent

                let sptcount =
                    spts.Descendants(XName.Get("SequencePoint"))
                    |> Seq.length

                let tmrcount =
                    spts.Descendants(XName.Get("TrackedMethodRef"))
                    |> Seq.length

                let name =
                    spts.Parent.Descendants(XName.Get("Name"))
                    |> Seq.head

                Assert.That(tmrcount, Is.EqualTo sptcount, name.Value)))

_Target
    "FSAsyncTests"
    (fun _ ->
        Directory.ensure "./_Reports"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"

        [ ("Sample27", 18); ("Sample30", 27) ]
        |> List.iter
            (fun (sample, methodcount) ->
                let simpleReport =
                    (Path.getFullName "./_Reports")
                    @@ (sample + "AltCoverFSAsyncTests.xml")

                let sampleRoot =
                    Path.getFullName "./_Binaries/FSAsyncTests_"
                    + sample
                    + "/Debug+AnyCPU/netcoreapp3.1"

                // Test the --inplace operation
                Shell.cleanDir sampleRoot

                sample + ".fsproj"
                |> DotNet.test
                    (fun o ->
                        { o.WithCommon(withWorkingDirectoryVM ("Samples/" + sample)) with
                              Framework = Some "netcoreapp3.1"
                              Configuration = DotNet.BuildConfiguration.Debug }
                        |> (testWithCLITaggedArguments "FSAsyncTests"))

                // instrument
                let prep =
                    AltCover.PrepareOptions.Primitive(
                        { Primitive.PrepareOptions.Create() with
                              Report = simpleReport
                              CallContext = [ "[Fact]" ]
                              AssemblyFilter = [ "Adapter"; "xunit" ]
                              TypeFilter = [ "System\\."; "Microsoft\\." ]
                              InPlace = true
                              LocalSource = true
                              ReportFormat = "OpenCover"
                              Save = false }
                    )
                    |> AltCoverCommand.Prepare

                { AltCoverCommand.Options.Create prep with
                      ToolPath = altcover
                      ToolType = dotnetAltcover
                      WorkingDirectory = sampleRoot }
                |> AltCoverCommand.run

                printfn "Execute the instrumented tests"

                let sampled =
                    Path.getFullName "./Samples/"
                    + sample
                    + "/"
                    + sample
                    + ".fsproj"

                let (dotnetexe, args) =
                    defaultDotNetTestCommandLine (Some "netcoreapp3.1") sampled

                let collect =
                    AltCover.CollectOptions.Primitive
                        { Primitive.CollectOptions.Create() with
                              Executable = dotnetexe
                              RecorderDirectory = sampleRoot
                              CommandLine = args @ [ "/p:AltCoverTag=FSAsyncTests_" ] }
                    |> AltCoverCommand.Collect

                { AltCoverCommand.Options.Create collect with
                      ToolPath = altcover
                      ToolType = dotnetAltcover
                      WorkingDirectory = "Samples/" + sample }
                |> AltCoverCommand.run

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(simpleReport))

                let methods =
                    coverageDocument.Descendants(XName.Get("Method"))
                    |> Seq.toList

                Assert.That(methods |> Seq.length, Is.EqualTo methodcount, "method count wrong")

                methods
                |> Seq.iter
                    (fun m ->
                        let spts = m.Element(XName.Get "SequencePoints")

                        let visited =
                            spts.Elements()
                            |> Seq.filter (fun sp -> sp.Attribute(XName.Get "vc").Value <> "0")
                            |> Seq.length

                        let tmrcount =
                            spts.Descendants(XName.Get("TrackedMethodRef"))
                            |> Seq.length

                        let name = m.Element(XName.Get("Name"))

                        Assert.That(tmrcount, Is.EqualTo visited, name.Value))))

_Target
    "FSharpTypesDotNetRunner"
    (fun _ ->
        Directory.ensure "./_Reports"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("AltCoverFSharpTypesDotNetRunner.xml")

        let sampleRoot =
            Path.getFullName "_Binaries/Sample2/Debug+AnyCPU/net6.0"

        let instrumented =
            Path.getFullName "_Binaries/FSharpTypesDotNetRunner_Sample2/Debug+AnyCPU/net6.0"

        // Instrument the code
        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      OutputDirectories = [ instrumented ]
                      AssemblyFilter = [ "Adapter"; "nunit"; "FSharp" ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        Actions.ValidateFSharpTypes simpleReport [ "main" ]

        printfn "Execute the instrumented tests"

        let sample2 =
            Path.getFullName "./Samples/Sample2/Sample2.fsproj"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "net6.0") sample2

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = instrumented
                      CommandLine =
                          args
                          @ [ "/p:AltCoverTag=FSharpTypesDotNetRunner_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = instrumented }
        |> AltCoverCommand.run

        Actions.ValidateFSharpTypesCoverage simpleReport)

_Target
    "FSharpTypesDotNetCollecter"
    (fun _ ->
        Directory.ensure "./_Reports"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("AltCoverFSharpTypesDotNetCollecter.xml")

        let simpleReport2 =
            (Path.getFullName "./_Reports/unzip")
            @@ ("AltCoverFSharpTypesDotNetCollecter.xml")

        let simpleReport3 =
            (Path.getFullName "./_Reports/unzip2")
            @@ ("AltCoverFSharpTypesDotNetCollecter.xml")

        let sampleRoot =
            Path.getFullName "_Binaries/FSharpTypesDotNetCollecter_Sample2/Debug+AnyCPU/net6.0"

        printfn "Build and test normally"
        Shell.cleanDir sampleRoot

        "Sample2.fsproj"
        |> DotNet.test
            (fun o ->
                { o.WithCommon(withWorkingDirectoryVM "Samples/Sample2") with
                      Configuration = DotNet.BuildConfiguration.Debug }
                |> (testWithCLITaggedArguments "FSharpTypesDotNetCollecter"))

        printfn "inplace instrument and save"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      AssemblyFilter = [ "Adapter"; "FSharp"; "nunit" ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      InPlace = true
                      ReportFormat = "NCover"
                      ZipFile = true
                      Save = true }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        printfn "Extract and verify the first results"
        System.IO.Compression.ZipFile.ExtractToDirectory(simpleReport + ".zip", Path.GetDirectoryName simpleReport3)
        Actions.ValidateFSharpTypes simpleReport3 [ "main" ]

        Assert.That(
            Path.Combine(sampleRoot, "__Saved")
            |> Directory.Exists
        )

        printfn "Execute the instrumented tests"

        "Sample2.fsproj"
        |> DotNet.test
            (fun o ->
                { o.WithCommon(withWorkingDirectoryVM "Samples/Sample2") with
                      Configuration = DotNet.BuildConfiguration.Debug
                      NoBuild = true }
                |> (testWithCLITaggedArguments "FSharpTypesDotNetCollecter"))

        printfn "Collect the results"

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      RecorderDirectory = sampleRoot }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        printfn "Extract and verify the results"
        System.IO.Compression.ZipFile.ExtractToDirectory(simpleReport + ".zip", Path.GetDirectoryName simpleReport2)
        Actions.ValidateFSharpTypesCoverage simpleReport2)

_Target
    "BasicCSharp"
    (fun _ ->
        Actions.SimpleInstrumentingRun
            "_Binaries/Sample1/Debug+AnyCPU/net20"
            "_Binaries/AltCover/Release+AnyCPU/net472"
            "BasicCSharp")

_Target
    "BasicCSharpMono"
    (fun _ ->
        Actions.SimpleInstrumentingRun "_Mono/Sample1" "_Binaries/AltCover/Release+AnyCPU/net472" "BasicCSharpMono")

_Target
    "BasicCSharpUnderMono"
    (fun _ ->
        monoOnWindows
        |> Actions.SimpleInstrumentingRunUnderMono
            "_Binaries/Sample1/Debug+AnyCPU/net20"
            "_Binaries/AltCover/Release+AnyCPU/net472"
            "BasicCSharpUnderMono")

_Target
    "BasicCSharpMonoUnderMono"
    (fun _ ->
        monoOnWindows
        |> Actions.SimpleInstrumentingRunUnderMono
            "_Mono/Sample1"
            "_Binaries/AltCover/Release+AnyCPU/net472"
            "BasicCSharpMono")

_Target
    "CSharpMonoWithDotNet"
    (fun _ ->
        Directory.ensure "./_Reports"

        let x =
            Path.getFullName "./_Reports/CSharpMonoWithDotNet.xml"

        let o =
            Path.getFullName "./_Mono/__Instrumented.CSharpMonoWithDotNet"

        let i = Path.getFullName "./_Mono/Sample1"

        let altcover =
            Path.getFullName "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      TypeFilter = [ "System\\." ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = altcover
              ToolType = dotnetAltcover
              WorkingDirectory = "." }
        |> AltCoverCommand.run

        Actions.Run(o @@ "/Sample1.exe", o, []) "Instrumented .exe failed"
        Actions.ValidateSample1 "./_Reports/CSharpMonoWithDotNet.xml" "CSharpMonoWithDotNet")

_Target
    "CSharpDotNetWithDotNet"
    (fun _ ->
        Directory.ensure "./_Reports"

        let x =
            Path.getFullName "./_Reports/CSharpDotNetWithDotNet.xml"

        let o =
            Path.getFullName "./_Binaries/Sample1/__Instrumented.CSharpDotNetWithDotNet"

        let i =
            Path.getFullName "./_Binaries/Sample1/Debug+AnyCPU/netcoreapp2.0"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      TypeFilter = [ "System\\." ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0/AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = "." }
        |> AltCoverCommand.run

        Actions.RunDotnet dotnetOptions "" (o @@ "Sample1.dll") "CSharpDotNetWithDotNet test"
        Actions.ValidateSample1 "./_Reports/CSharpDotNetWithDotNet.xml" "CSharpDotNetWithDotNet")

_Target
    "CSharpDotNetWithFramework"
    (fun _ ->
        Directory.ensure "./_Reports"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("CSharpDotNetWithFramework.xml")

        let binRoot =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472"

        let sampleRoot =
            Path.getFullName "_Binaries/Sample1/Debug+AnyCPU/netcoreapp2.0"

        let instrumented =
            Path.getFullName "_Binaries/Sample1/__Instrumented.CSharpDotNetWithFramework"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      OutputDirectories = [| instrumented |]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = binRoot @@ "AltCover.exe"
              ToolType = frameworkAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        Actions.RunDotnet dotnetOptions "" (instrumented @@ "Sample1.dll") "CSharpDotNetWithFramework test"
        Actions.ValidateSample1 simpleReport "CSharpDotNetWithFramework")

_Target
    "RecordResumeTest"
    (fun _ ->
        Directory.ensure "./_Reports"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("RecordResumeTest.xml")

        let sampleRoot =
            Path.getFullName "_Binaries/Sample8/Debug+AnyCPU/net20"

        let instrumented = "__RecordResumeTest"

        let toolPath =
            match NuGetAltCover with
            | Some test ->
                Trace.traceImportant "Using the NuGet package"
                test
            | _ -> Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/AltCover.exe"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      OutputDirectories = [ instrumented ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      AssemblyFilter = [ "Adapter"; "nunit"; "xunit" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = toolPath
              ToolType = frameworkAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        let testing =
            (sampleRoot @@ instrumented) @@ "Sample8.exe"

        Actions.Run(testing, sampleRoot, [ simpleReport + ".acv" ]) "RecordResumeTest 2"

        do
            use coverageFile =
                new FileStream(
                    simpleReport,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.None,
                    4096,
                    FileOptions.SequentialScan
                )

            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let recorded =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get("visitcount")).Value)
                |> Seq.toList

            let expected = Array.create 20 "0"

            Assert.That(
                recorded,
                expected |> Is.EquivalentTo,
                sprintf "Bad visit list %A -- should be empty now" recorded
            )

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      RecorderDirectory = instrumented }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = toolPath
              ToolType = frameworkAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        do
            use coverageFile =
                new FileStream(
                    simpleReport,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.None,
                    4096,
                    FileOptions.SequentialScan
                )

            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let recorded =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get("visitcount")).Value)
                |> Seq.toList

            Assert.That(recorded |> Seq.length, Is.EqualTo 20, sprintf "Bad visit list %A -- bad length" recorded)

            let hits =
                recorded
                |> Seq.filter (fun i -> i = "1")
                |> Seq.length

            Assert.That(hits, Is.GreaterThanOrEqualTo 4)
            Assert.That(hits, Is.LessThanOrEqualTo 8))

_Target
    "RecordResumeTrackingTest"
    (fun _ ->
        Directory.ensure "./_Reports"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("RecordResumeTrackingTest.xml")

        let sampleRoot =
            Path.getFullName "_Binaries/Sample8/Debug+AnyCPU/net20"

        let instrumented = "__RecordResumeTrackingTest"

        let toolPath =
            match NuGetAltCover with
            | Some test ->
                Trace.traceImportant "Using the NuGet package"
                test
            | _ -> Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/AltCover.exe"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      OutputDirectories = [ instrumented ]
                      CallContext = [ "Main" ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      AssemblyFilter = [ "Adapter"; "nunit" ]
                      InPlace = false
                      ReportFormat = "OpenCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = toolPath
              ToolType = frameworkAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        let testing =
            (sampleRoot @@ instrumented) @@ "Sample8.exe"

        Actions.Run(testing, sampleRoot, [ simpleReport + ".acv" ]) "RecordResumeTrackingTest 2"

        do
            use coverageFile =
                new FileStream(
                    simpleReport,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.None,
                    4096,
                    FileOptions.SequentialScan
                )

            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let recorded =
                coverageDocument.Descendants(XName.Get("SequencePoint"))
                |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                |> Seq.toList

            let expected = Array.create 20 "0"

            Assert.That(
                recorded,
                expected |> Is.EquivalentTo,
                sprintf "Bad visit list %A -- should be empty now" recorded
            )

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      RecorderDirectory = instrumented }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = toolPath
              ToolType = frameworkAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        do
            use coverageFile =
                new FileStream(
                    simpleReport,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.None,
                    4096,
                    FileOptions.SequentialScan
                )

            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let recorded =
                coverageDocument.Descendants(XName.Get("SequencePoint"))
                |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                |> Seq.toList

            Assert.That(recorded |> Seq.length, Is.EqualTo 20, sprintf "Bad visit list %A -- bad length" recorded)

            let hits =
                recorded
                |> Seq.filter (fun i -> i = "1")
                |> Seq.length

            Assert.That(hits, Is.GreaterThanOrEqualTo 4)
            Assert.That(hits, Is.LessThanOrEqualTo 8)

            let tracked =
                coverageDocument.Descendants(XName.Get("TrackedMethodRef"))
                |> Seq.toList

            Assert.That(tracked, Is.Not.Empty))

_Target
    "RecordResumeTestDotNet"
    (fun _ ->
        Directory.ensure "./_Reports"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("RecordResumeTestDotNet.xml")

        let binRoot =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/netcoreapp2.0"

        let sampleRoot =
            Path.getFullName "_Binaries/Sample8/Debug+AnyCPU/netcoreapp2.0"

        let instrumented = "__RecordResumeTestDotNet"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      OutputDirectories = [ instrumented ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      AssemblyFilter = [ "Adapter"; "nunit" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = binRoot @@ "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        let testing =
            (sampleRoot @@ instrumented) @@ "Sample8.dll"

        Actions.RunDotnet
            (fun o ->
                { dotnetOptions o with
                      WorkingDirectory = sampleRoot })
            ""
            (testing + " " + simpleReport + ".acv")
            "RecordResumeTestDotNet 2"

        do
            use coverageFile =
                new FileStream(
                    simpleReport,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.None,
                    4096,
                    FileOptions.SequentialScan
                )

            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let recorded =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get("visitcount")).Value)
                |> Seq.toList

            let expected = Array.create 20 "0"

            Assert.That(
                recorded,
                expected |> Is.EquivalentTo,
                sprintf "Bad visit list %A -- should be empty now" recorded
            )

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      RecorderDirectory = instrumented }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = binRoot @@ "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        do
            use coverageFile =
                new FileStream(
                    simpleReport,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.None,
                    4096,
                    FileOptions.SequentialScan
                )

            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let recorded =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get("visitcount")).Value)
                |> Seq.toList

            Assert.That(recorded |> Seq.length, Is.EqualTo 20, sprintf "Bad visit list %A -- bad length" recorded)

            let hits =
                recorded
                |> Seq.filter (fun i -> i = "1")
                |> Seq.length

            Assert.That(hits, Is.GreaterThanOrEqualTo 4)
            Assert.That(hits, Is.LessThanOrEqualTo 8))

// Packaging

_Target
    "Packaging"
    (fun _ ->
        let AltCover =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/AltCover.exe"

        let engine =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/AltCover.Engine.dll"

        let config = AltCover + ".config"

        let manatee =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/Manatee.Json.dll"

        let fox =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/BlackFox.CommandLine.dll"

        let fscore =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/FSharp.Core.dll"

        let options =
            Path.getFullName "_Binaries/AltCover/Release+AnyCPU/net472/Mono.Options.dll"

        let monitor =
            Path.getFullName "_Binaries/AltCover.Monitor/Release+AnyCPU/net20/AltCover.Monitor.dll"

        let poshHelp =
            Path.getFullName
                "_Binaries/AltCover.PowerShell/Release+AnyCPU/netstandard2.0/AltCover.PowerShell.dll-Help.xml"

        if (poshHelp |> File.Exists |> not)
           && (Environment.isWindows |> not) then // as the cmdletdoc tool uses a windows-only toolkit
            File.WriteAllText(
                poshHelp,
                "<?xml version=\"1.0\" encoding=\"utf-8\"?><helpItems schema=\"maml\" xmlns=\"http://msh\" />"
            )

        let vis =
            Path.getFullName "_Binaries/AltCover.Visualizer/Release+AnyCPU/net472/AltCover.Visualizer.exe"

        let uic =
            Path.getFullName "_Binaries/AltCover.Visualizer/Release+AnyCPU/net472/AltCover.UICommon.dll"

        let libFiles path =
            Seq.concat [ !! "./_Binaries/AltCover/Release+AnyCPU/net472/Mono.C*.dll"
                         !! "_Publish/System.*" ]
            |> Seq.map (fun f -> (f |> Path.getFullName, Some path, None))
            |> Seq.toList

        let housekeeping =
            [ (Path.getFullName "./LICENS*", Some "", None)
              (Path.getFullName "./Build/AltCover_128.*", Some "", None) ]

        let housekeepingVis =
            [ (Path.getFullName "./LICENS*", Some "", None)
              (Path.getFullName "./AltCover.UICommon/logo.*", Some "", None) ]

        let applicationFiles =
            [ (AltCover, Some "tools/net472", None)
              (engine, Some "tools/net472", None)
              (config, Some "tools/net472", None)
              (monitor, Some "lib/net20", None)
              (vis, Some "tools/net472", None)
              (uic, Some "tools/net472", None)
              (fscore, Some "tools/net472", None)
              (manatee, Some "tools/net472", None)
              (fox, Some "tools/net472", None)
              (options, Some "tools/net472", None)
              (Path.getFullName "Build/README.core.md", Some "", None)
              (Path.getFullName "./_Binaries/README.core.html", Some "", None) ]

        let apiFiles =
            [ (AltCover, Some "lib/net472", None)
              (engine, Some "lib/net472", None)
              (config, Some "lib/net472", None)
              (monitor, Some "lib/net472", None)
              (monitor, Some "lib/net20", None)
              (fscore, Some "lib/net472", None)
              (manatee, Some "lib/net472", None)
              (fox, Some "lib/net472", None)
              (options, Some "lib/net472", None)
              (Path.getFullName "Build/README.api.md", Some "", None)
              (Path.getFullName "./_Binaries/README.api.html", Some "", None) ]

        let resourceFiles path =
            [ "_Binaries/AltCover/Release+AnyCPU/net472"
              "_Binaries/AltCover.Visualizer/Release+AnyCPU/net472" ]
            |> List.map
                (fun f ->
                    Directory.GetDirectories(Path.getFullName f)
                    |> Seq.collect (fun d -> Directory.GetFiles(d, "*.resources.dll")))
            |> Seq.concat
            |> Seq.map (fun x -> (x, Some(path + Path.GetFileName(Path.GetDirectoryName(x))), None))
            |> Seq.distinctBy (fun (x, y, _) -> (Option.get y) + "/" + (Path.GetFileName x))
            |> Seq.toList

        let nupkg = (Path.getFullName "./nupkg").Length

        let otherFiles =
            (!! "./nupkg/**/*.*")
            |> Seq.map
                (fun x ->
                    (x,
                     Some(
                         Path
                             .GetDirectoryName(x)
                             .Substring(nupkg)
                             .Replace("\\", "/")
                     ),
                     None))
            |> Seq.toList

        Directory.ensure "./_Intermediate/global"

        let otherFilesGlobal =
            otherFiles
            |> List.map
                (fun (a, b, c) ->
                    let text =
                        File
                            .ReadAllText(a)
                            .Replace("tools/netcoreapp2.0", "tools/netcoreapp2.1/any")

                    let name =
                        (Path.getFullName "./_Intermediate/global")
                        @@ ("altcover.global" + Path.GetExtension a)

                    File.WriteAllText(name, text)
                    (name, b, c))

        Directory.ensure "./_Intermediate/api"

        let otherFilesApi =
            otherFiles
            |> List.map
                (fun (a, b, c) ->
                    let text =
                        File
                            .ReadAllText(a)
                            .Replace("tools/netcoreapp2.0", "lib/netstandard2.0")

                    let name =
                        (Path.getFullName "./_Intermediate/api")
                        @@ ("altcover.api" + Path.GetExtension a)

                    File.WriteAllText(name, text)
                    (name, b, c))

        let poshFiles where =
            [ (!! "./_Binaries/AltCover.PowerShell/Release+AnyCPU/netstandard2.0/*.PowerShell.*")
              (!! "./_Binaries/AltCover.Toolkit/Release+AnyCPU/netstandard2.0/*.Toolkit.*") ]
            |> Seq.concat
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let poshHelpFiles where =
            [ poshHelp ]
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let cakeFiles where =
            (!! "./_Binaries/AltCover.Cake/Release+AnyCPU/netstandard2.0/AltCover.C*.*")
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let monitorFiles where =
            (!! "./_Binaries/AltCover.Monitor/Release+AnyCPU/netstandard2.0/AltCover.M*.*")
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let dataFiles1 where =
            (!! "./_Binaries/AltCover.DataCollector/Release+AnyCPU/netstandard2.0/AltCover.D*.*")
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let dataFiles2 where =
            (!! "./_Binaries/AltCover.DataCollector/Release+AnyCPU/netstandard2.0/*/AltCover.DataCollector.resources.dll")
            |> Seq.map
                (fun x ->
                    let d = Path.GetDirectoryName x
                    let locale = Path.GetFileName d
                    (x, Some(where + locale + "/" + (Path.GetFileName x)), None))
            |> Seq.toList

        let dataFiles where =
            [ dataFiles1; dataFiles2 ]
            |> List.collect (fun f -> f where)

        let fakeFiles where =
            [ (!! "./_Binaries/AltCover.Fake/Release+AnyCPU/netstandard2.0/AltCover.Fak*.*")
              (!! "./_Binaries/AltCover.DotNet/Release+AnyCPU/netstandard2.0/AltCover.Dot*.*") ]
            |> Seq.concat
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let fake2Files where =
            (!! "./_Binaries/AltCover.Fake.DotNet.Testing.AltCover/Release+AnyCPU/netstandard2.0/AltCover.Fake.DotNet.*")
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let fox2Files where =
            (!! "./_Publish/BlackFox.*")
            |> Seq.map (fun x -> (x, Some(where + Path.GetFileName x), None))
            |> Seq.toList

        let publish = (Path.getFullName "./_Publish").Length

        let netcoreFiles where =
            (!! "./_Publish/**/*.*")
            |> Seq.map
                (fun x ->
                    (x,
                     Some(
                         where
                         + Path
                             .GetDirectoryName(x)
                             .Substring(publish)
                             .Replace("\\", "/")
                     ),
                     None))
            |> Seq.toList

        let publishapi = (Path.getFullName "./_Publish").Length

        let netstdFiles where =
            (!! "./_Publish/**/*.*")
            |> Seq.map
                (fun x ->
                    (x,
                     Some(
                         where
                         + Path
                             .GetDirectoryName(x)
                             .Substring(publishapi)
                             .Replace("\\", "/")
                     ),
                     None))
            |> Seq.toList

        let globalFiles =
            (!! "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.1/AltCover.*")
            |> Seq.map (fun x -> (x, Some("tools/netcoreapp2.1/any/" + Path.GetFileName x), None))
            |> Seq.toList

        let publishV =
            (Path.getFullName "./_Publish.visualizer").Length

        let vizFiles where =
            (!! "./_Publish.visualizer/**/*.*")
            |> Seq.map
                (fun x ->
                    (x,
                     Some(
                         where
                         + Path
                             .GetDirectoryName(x)
                             .Substring(publishV)
                             .Replace("\\", "/")
                     ),
                     None))
            |> Seq.toList

        let auxVFiles =
            [ (!! "./_Binaries/AltCover.Visualizer/Release+AnyCPU/netcoreapp2.1/*.xml") ]
            |> Seq.concat
            |> Seq.map (fun x -> (x, Some("tools/netcoreapp2.1/any/" + Path.GetFileName x), None))
            |> Seq.toList

        let auxFiles =
            (!! "./_Binaries/AltCover/Release+AnyCPU/netcoreapp2.1/*.xml")
            |> Seq.map (fun x -> (x, Some("tools/netcoreapp2.1/any/" + Path.GetFileName x), None))
            |> Seq.toList

        printfn "Executing on %A" Environment.OSVersion

        [ (List.concat [ applicationFiles
                         resourceFiles "tools/net472/"
                         libFiles "tools/net472/"
                         netcoreFiles "tools/netcoreapp2.0/"
                         poshFiles "tools/netcoreapp2.0/"
                         poshHelpFiles "tools/netcoreapp2.0/"
                         dataFiles "tools/netcoreapp2.0/"
                         monitorFiles "lib/netstandard2.0/"
                         otherFiles
                         housekeeping ],
           [],
           "_Packaging",
           "./Build/AltCover.nuspec",
           "altcover")

          (List.concat [ apiFiles
                         resourceFiles "lib/net472/"
                         libFiles "lib/net472/"
                         netstdFiles "lib/netstandard2.0"
                         cakeFiles "lib/netstandard2.0/"
                         dataFiles "lib/netstandard2.0/"
                         monitorFiles "lib/netstandard2.0/"
                         fakeFiles "lib/netstandard2.0/"
                         poshFiles "lib/netstandard2.0/"
                         poshHelpFiles "lib/netstandard2.0/"
                         otherFilesApi
                         housekeeping ],
           [],
           "_Packaging.api",
           "./_Generated/altcover.api.nuspec",
           "altcover.api")

          (List.concat [ globalFiles
                         netcoreFiles "tools/netcoreapp2.1/any"
                         poshFiles "tools/netcoreapp2.1/any/"
                         poshHelpFiles "tools/netcoreapp2.1/any/"
                         dataFiles "tools/netcoreapp2.1/any/"
                         // monitorFiles "lib/netstandard2.0/"
                         // [ (monitor, Some "lib/net20", None) ]
                         monitorFiles "tools/netcoreapp2.1/any/"
                         [ (Path.getFullName "Build/README.global.md", Some "", None)
                           (Path.getFullName "./_Binaries/README.global.html", Some "", None) ]
                         auxFiles
                         otherFilesGlobal
                         housekeeping ],
           [],
           "_Packaging.global",
           "./_Generated/altcover.global.nuspec",
           "altcover.global")

          (List.concat [ vizFiles "tools/netcoreapp2.1/any"
                         [ (Path.getFullName "Build/README.visualizer.md", Some "", None)
                           (Path.getFullName "./_Binaries/README.visualizer.html", Some "", None) ]
                         auxVFiles
                         housekeepingVis ],
           [],
           "_Packaging.visualizer",
           "./_Generated/altcover.visualizer.nuspec",
           "altcover.visualizer")

          (List.concat [ fake2Files "lib/netstandard2.0/"
                         fox2Files "lib/netstandard2.0/"
                         [ (Path.getFullName "Build/README.fake.md", Some "", None)
                           (Path.getFullName "./_Binaries/README.fake.html", Some "", None) ]
                         housekeeping ],
           [ // make these explicit, as this package implies an opt-in
             ("BlackFox.CommandLine", "1.0.0")
             ("FAKE.Core.Environment", "5.21.0")
             ("FAKE.Core.Process", "5.21.0")
             ("FAKE.DotNet.Cli", "5.21.0")
             ("System.Collections.Immutable", "1.7.1")
             ("FSharp.Core", "6.0.1") ],
           "_Packaging.fake",
           "./_Generated/altcover.fake.nuspec",
           "altcover.fake") ]
        |> List.iter
            (fun (files, dependencies, output, nuspec, project) ->
                let outputPath = "./" + output
                let workingDir = "./_Binaries/" + output
                Directory.ensure workingDir
                Directory.ensure outputPath

                NuGetPack
                    (fun p ->
                        { p with
                              Authors = [ "Steve Gilham" ]
                              Project = project
                              Description =
                                  "A cross-platform pre-instrumenting code coverage tool set for .net/.net core and Mono"
                              OutputPath = outputPath
                              WorkingDir = workingDir
                              Files =
                                  files
                                  |> List.distinctBy
                                      (fun (f1, f2, _) ->
                                          let name = Path.GetFileName f1

                                          let path =
                                              match f2 with
                                              | Some s -> s.Replace("\\", "/")
                                              | _ -> ""

                                          if path.EndsWith(name, StringComparison.Ordinal) then
                                              path
                                          else
                                              path + "/" + name)
                              Dependencies = dependencies
                              Version = Version.Value
                              Copyright = Copyright.Value
                              Publish = false
                              ReleaseNotes =
                                  let source =
                                      Path.getFullName "ReleaseNotes.md"
                                      |> File.ReadAllLines
                                      |> Seq.map
                                          (fun s ->
                                              let t =
                                                  System.Text.RegularExpressions.Regex.Replace(s, "^\*\s", "* â¢\u00A0")

                                              let u =
                                                  System.Text.RegularExpressions.Regex.Replace(
                                                      t,
                                                      "^\s\s\*\s", // â¦ U+25E6 WHITE BULLET
                                                      "  * \u00A0\u00A0\u25E6\u00A0"
                                                  )

                                              let v =
                                                  System.Text.RegularExpressions.Regex.Replace(
                                                      u,
                                                      "^\s\s\s+\*\s", // â U+2043 HYPHEN BULLET,
                                                      "    * \u00A0\u00A0\u00A0\u00A0\u2043\u00A0"
                                                  )

                                              System.Text.RegularExpressions.Regex.Replace(
                                                  v,
                                                  "^#\s", // â U+204B REVERSED PILCROW SIGN
                                                  "# \u204B"
                                              ))
                                      |> (fun s -> String.Join(Environment.NewLine, s))

                                  use w = new StringWriter()
                                  // printfn "tweaked = %A" source
                                  Markdig.Markdown.ToPlainText(source, w) |> ignore

                                  let releaseNotes =
                                      "This build from https://github.com/SteveGilham/altcover/tree/"
                                      + commitHash
                                      + Environment.NewLine
                                      + Environment.NewLine
                                      + w
                                          .ToString()
                                          .Replace("\u204B", Environment.NewLine)

                                  printfn "release notes are %A characters" releaseNotes.Length
                                  Assert.That(releaseNotes.Length, Is.LessThan 35000)
                                  releaseNotes
                              ToolPath =
                                  ("./packages/"
                                   + (packageVersion "NuGet.CommandLine")
                                   + "/tools/NuGet.exe")
                                  |> Path.getFullName })
                    nuspec))

_Target "PrepareFrameworkBuild" ignore

_Target
    "PrepareDotNetBuild"
    (fun _ ->
        let netcoresource =
            Path.getFullName "./AltCover/AltCover.fsproj"

        let publish = Path.getFullName "./_Publish"

        DotNet.publish
            (fun options ->
                { options with
                      OutputPath = Some publish
                      Configuration = DotNet.BuildConfiguration.Release
                      MSBuildParams =
                          { options.MSBuildParams with
                                Properties = options.MSBuildParams.Properties }
                      Framework = Some "netcoreapp2.0" })
            netcoresource

        DotNet.publish
            (fun options ->
                { options with
                      OutputPath = Some(publish + ".visualizer")
                      Configuration = DotNet.BuildConfiguration.Release
                      MSBuildParams =
                          { options.MSBuildParams with
                                Properties = options.MSBuildParams.Properties }
                      Framework = Some "netcoreapp2.1" })
            (Path.getFullName "./AltCover.Avalonia/AltCover.Avalonia.fsproj")

        // dotnet tooling mods
        [ ("DotnetTool",
           "./_Generated/altcover.global.nuspec",
           "AltCover (dotnet global tool install)",
           None,
           "README.global.md",
           None)

          ("DotnetTool",
           "./_Generated/altcover.visualizer.nuspec",
           "AltCover.Visualizer (dotnet global tool install)",
           Some "AltCover.UICommon/logo.png",
           "README.visualizer.md",
           Some "codecoverage .netcore cross-platform")

          (String.Empty, "./_Generated/altcover.api.nuspec", "AltCover (API install)", None, "README.api.md", None)

          (String.Empty,
           "./_Generated/altcover.fake.nuspec",
           "AltCover (FAKE task helpers)",
           None,
           "README.fake.md",
           Some "codecoverage .net Mono .netcore cross-platform FAKE build") ]
        |> List.iter
            (fun (ptype, path, caption, icon, readme, tags) ->
                let x s =
                    XName.Get(s, "http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd")

                let dotnetNupkg = XDocument.Load "./Build/AltCover.nuspec"

                dotnetNupkg.Descendants(x "readme")
                |> Seq.iter (fun hint -> hint.SetValue readme)

                let title =
                    dotnetNupkg.Descendants(x "title") |> Seq.head

                title.ReplaceNodes caption

                if ptype |> String.IsNullOrWhiteSpace |> not then
                    let tag =
                        dotnetNupkg.Descendants(x "tags") |> Seq.head

                    let insert = XElement(x "packageTypes")
                    insert.Add(XElement(x "packageType", XAttribute(XName.Get "name", ptype)))
                    tag.AddAfterSelf insert

                match icon with
                | None -> ()
                | Some logo ->
                    let tag =
                        dotnetNupkg.Descendants(x "iconUrl") |> Seq.head

                    tag.Value <- tag.Value.Replace("Build/AltCover_128.png", logo)

                    let tag2 =
                        dotnetNupkg.Descendants(x "icon") |> Seq.head

                    tag2.Value <- tag2.Value.Replace("AltCover_128.png", Path.GetFileName logo)

                match tags with
                | None -> ()
                | Some line ->
                    let tagnode =
                        dotnetNupkg.Descendants(x "tags") |> Seq.head

                    tagnode.Value <- line

                dotnetNupkg.Save path))

_Target
    "PrepareReadMe"
    (fun _ ->
        let c =
            Copyright
                .Value
                .Replace("Â©", "&#xa9;")
                .Replace("<", "&lt;")
                .Replace(">", "&gt;")

        [ "./Build/README.core.md"
          "./Build/README.api.md"
          "./Build/README.fake.md"
          "./Build/README.global.md"
          "./Build/README.visualizer.md" ]
        |> Seq.iter (Actions.PrepareReadMe c))

// Post-packaging deployment touch test

_Target "Deployment" ignore

_Target
    "Unpack"
    (fun _ ->
        !! "./_Pack*/*.nupkg"
        |> Seq.iter
            (fun nugget ->
                let packdir = Path.GetDirectoryName nugget
                let unpack = Path.getFullName (packdir @@ "Unpack")
                System.IO.Compression.ZipFile.ExtractToDirectory(nugget, unpack))

        // C# style API documentation
        let packages =
            let xml =
                [ "./AltCover.PowerShell/AltCover.PowerShell.fsproj"
                  "./AltCover.Cake/AltCover.Cake.csproj"
                  "./AltCover.Monitor/AltCover.Monitor.csproj" ]
                |> List.map (Path.getFullName >> XDocument.Load)

            xml
            |> List.map (fun x -> x.Descendants(XName.Get("PackageReference")))
            |> Seq.concat
            |> Seq.map
                (fun x ->
                    let incl = x.Attribute(XName.Get("Include"))
                    let update = x.Attribute(XName.Get("Update"))
                    let version = x.Attribute(XName.Get("Version")).Value

                    if incl |> isNull then
                        (update.Value, version)
                    else
                        (incl.Value, version))
            |> Seq.distinctBy fst
            |> Map.ofSeq

        let packageVersionPart (p: string) =
            nugetCache
            + "/"
            + p.ToLowerInvariant()
            + "/"
            + (packages.Item p)
            + "/lib/netstandard2.0/"

        let unpacked =
            "./_Packaging.api/Unpack/lib/netstandard2.0/"

        Shell.copyFile (unpacked + "Cake.Core.dll") ((packageVersionPart "Cake.Core") + "Cake.Core.dll")

        Shell.copyFile
            (unpacked + "Cake.Common.dll")
            ((packageVersionPart "Cake.Common")
             + "Cake.Common.dll")

        Shell.copyFile
            (unpacked + "System.Management.Automation.dll")
            ((packageVersionPart "PowerShellStandard.Library")
             + "System.Management.Automation.dll")

        [ "AltCover.Cake"
          "AltCover.DotNet"
          "AltCover.Engine" // beware static linkage -- maybe copy from debug?
          "AltCover.Monitor"
          "AltCover.PowerShell"
          "AltCover.Toolkit" ]
        |> List.iter
            (fun n ->
                Shell.copyFile
                    (unpacked + n + ".xml")
                    ("./_Binaries/"
                     + n
                     + "/Release+AnyCPU/netstandard2.0/"
                     + n
                     + ".xml")

                Actions.RunDotnet
                    (dotnetOptions >> dotnetOptionsWithRollForwards)
                    "xmldocmd"
                    (unpacked
                     + n
                     + ".dll ./_Documentation/"
                     + n
                     + " --visibility public --skip-unbrowsable --clean")
                    ("documenting " + n)))

_Target
    "WindowsPowerShell"
    (fun _ ->
        Directory.ensure "./_Documentation"

        let v = Version.Value.Split([| '-' |]).[0]

        let unpackapi =
            Path.getFullName "_Packaging.api/Unpack/lib/netstandard2.0"

        CreateProcess.fromRawCommand
            "powershell.exe"
            [ "-NoProfile"
              "./Build/pester.ps1"
              "-ACV"
              v
              "-ReportName"
              "PoshReport"
              "-FolderName"
              unpackapi ]
        |> CreateProcess.withWorkingDirectory "."
        |> Proc.run
        |> (Actions.AssertResult "powershell"))

_Target
    "Pester"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let unpackapi =
            Path.getFullName "_Packaging.api/Unpack/lib/netstandard2.0"

        let report =
            Path.getFullName "_Reports/RawPester.xml"

        let fixedReport = Path.getFullName "_Reports/Pester.xml"
        let v = Version.Value.Split([| '-' |]).[0]

        let key =
            Path.getFullName "Build/Infrastructure.snk"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = report
                      InputDirectories = [ unpackapi ]
                      StrongNameKey = key
                      TypeFilter = [ "System\\."; "DotNet"; "EntryPoint" ]
                      AssemblyFilter =
                          [ "AltCover.Engine"
                            "AltCover.Monitor"
                            "AltCover.Fake"
                            "AltCover.Cake"
                            "Recorder"
                            "DataCollector"
                            "FSharp" ]
                      InPlace = false
                      ReportFormat = "OpenCover"
                      Save = true
                      VisibleBranches = true }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        printfn "Execute the instrumented tests"

        CreateProcess.fromRawCommand
            pwsh
            [ "-NoProfile"
              "./Build/pester.ps1"
              "-ACV"
              v
              "-ReportName"
              "PesterReport"
              "-FolderName"
              unpackapi @@ "__Instrumented" ]
        |> CreateProcess.withWorkingDirectory "."
        |> Proc.run
        |> (Actions.AssertResult "pwsh")

        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      RecorderDirectory = unpackapi @@ "__Instrumented" }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        let xml =
            report |> Path.getFullName |> XDocument.Load

        xml.Descendants(XName.Get "File")
        |> Seq.iter
            (fun x ->
                let path = x.Attribute(XName.Get "fullPath").Value
                let part = path.TrimStart([| '/'; '_' |])

                let newpath =
                    Path.Combine(Path.getFullName ".", Path.GetDirectoryName part, Path.GetFileName part)

                x.Attribute(XName.Get "fullPath").Value <- newpath)

        xml.Save fixedReport

        ReportGenerator.generateReports
            (fun p ->
                { p with
                      ToolType = ToolType.CreateLocalTool()
                      ReportTypes =
                          [ ReportGenerator.ReportType.Html
                            ReportGenerator.ReportType.XmlSummary ]
                      TargetDir = "_Reports/_Pester" })
            [ fixedReport ]

        "_Reports/_Pester/Summary.xml"
        |> File.ReadAllText
        |> printfn "%s")

_Target
    "SimpleReleaseTest"
    (fun _ ->
        let unpack =
            match NuGetAltCover with
            | Some test ->
                Trace.traceImportant "Using the NuGet package"
                Path.GetDirectoryName test
            | _ -> Path.getFullName "_Packaging/Unpack/tools/net472"

        Actions.SimpleInstrumentingRun "_Binaries/Sample1/Debug+AnyCPU/net20" unpack "SimpleReleaseTest")

_Target
    "SimpleZipReleaseTest"
    (fun _ ->
        let binaryPath =
            match NuGetAltCover with
            | Some test ->
                Trace.traceImportant "Using the NuGet package"
                Path.GetDirectoryName test
            | _ -> Path.getFullName "_Packaging/Unpack/tools/net472"

        let reportSigil = "SimpleZipReleaseTest"

        printfn "Instrument and run a simple executable"
        Directory.ensure "./_Reports"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ (reportSigil + ".xml")

        let binRoot = Path.getFullName binaryPath

        let sampleRoot =
            Path.getFullName "_Binaries/Sample1/Debug+AnyCPU/net20"

        let instrumented = "__Instrumented." + reportSigil

        let framework =
            Fake.DotNet.ToolType.CreateFullFramework()

        let prep =
            AltCover.PrepareOptions.Primitive
                { Primitive.PrepareOptions.Create() with
                      TypeFilter = [ """System\.""" ]
                      Report = simpleReport
                      OutputDirectories = [| "./" + instrumented |]
                      ReportFormat = "NCover"
                      ZipFile = true
                      InPlace = false
                      Save = false }
            |> AltCoverCommand.Prepare

        let parameters =
            { AltCoverCommand.Options.Create prep with
                  ToolPath = binRoot @@ "AltCover.exe"
                  ToolType = framework
                  WorkingDirectory = sampleRoot }

        AltCoverCommand.run parameters
        System.Threading.Thread.Sleep(1000)

        Actions.Run
            (sampleRoot @@ (instrumented + "/Sample1.exe"), (sampleRoot @@ instrumented), [])
            "Instrumented .exe failed"

        System.Threading.Thread.Sleep(1000)

        printfn "Extract and verify the first results"

        System.IO.Compression.ZipFile.ExtractToDirectory(
            simpleReport + ".zip",
            (Path.GetDirectoryName simpleReport)
            @@ ("unzip" + reportSigil)
        )

        Actions.ValidateSample1
            (((Path.GetDirectoryName simpleReport)
              @@ ("unzip" + reportSigil))
             @@ (Path.GetFileName simpleReport))
            reportSigil)

_Target
    "SimpleMonoReleaseTest"
    (fun _ ->
        let unpack =
            match NuGetAltCover with
            | Some test ->
                Trace.traceImportant "Using the NuGet package"
                Path.GetDirectoryName test
            | _ -> Path.getFullName "_Packaging/Unpack/tools/net472"

        Actions.SimpleInstrumentingRun "_Mono/Sample1" unpack "SimpleMonoReleaseTest")

_Target
    "ReleaseDotNetWithFramework"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            match NuGetAltCover with
            | Some test ->
                Trace.traceImportant "Using the NuGet package"
                Path.GetDirectoryName test
            | _ -> Path.getFullName "_Packaging/Unpack/tools/net472"

        let simpleReport =
            (Path.getFullName "./_Reports")
            @@ ("ReleaseDotNetWithFramework.xml")

        let sampleRoot =
            Path.getFullName "./_Binaries/Sample1/Debug+AnyCPU/netcoreapp2.0"

        let instrumented =
            sampleRoot
            @@ "__Instrumented.ReleaseDotNetWithFramework"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = simpleReport
                      OutputDirectories = [ instrumented ]
                      TypeFilter = [ "System\\."; "Microsoft\\." ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = (unpack @@ "AltCover.exe")
              ToolType = frameworkAltcover
              WorkingDirectory = sampleRoot }
        |> AltCoverCommand.run

        Actions.RunDotnet
            (fun o ->
                { dotnetOptions o with
                      WorkingDirectory = instrumented })
            ""
            "Sample1.dll"
            "ReleaseDotNetWithFramework test"

        Actions.ValidateSample1 "./_Reports/ReleaseDotNetWithFramework.xml" "ReleaseDotNetWithFramework")

_Target
    "ReleaseMonoWithDotNet"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let x =
            Path.getFullName "./_Reports/ReleaseMonoWithDotNet.xml"

        let o =
            Path.getFullName "./_Mono/__Instrumented.ReleaseMonoWithDotNet"

        let i = Path.getFullName "./_Mono/Sample1"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        Actions.Run(o @@ "Sample1.exe", o, []) "Instrumented .exe failed"
        Actions.ValidateSample1 "./_Reports/ReleaseMonoWithDotNet.xml" "ReleaseMonoWithDotNet")

_Target
    "ReleaseDotNetWithDotNet"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let x =
            Path.getFullName "./_Reports/ReleaseDotNetWithDotNet.xml"

        let o =
            Path.getFullName "./_Binaries/Sample1/__Instrumented.ReleaseDotNetWithDotNet"

        let i =
            Path.getFullName "./_Binaries/Sample1/Debug+AnyCPU/netcoreapp2.0"

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        Actions.RunDotnet dotnetOptions "" (o @@ "Sample1.dll") "ReleaseDotNetWithDotNet test"
        Actions.ValidateSample1 "./_Reports/ReleaseDotNetWithDotNet.xml" "ReleaseDotNetWithDotNet")

_Target
    "ReleaseFSharpTypesDotNetRunner"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let x =
            Path.getFullName "./_Reports/AltCoverReleaseFSharpTypesDotNetRunner.xml"

        let o =
            Path.getFullName "./_Binaries/ReleaseFSharpTypesDotNetRunner_Sample2/Debug+AnyCPU/net6.0"

        let i =
            Path.getFullName "_Binaries/Sample2/Debug+AnyCPU/net6.0"

        Shell.cleanDir o

        // Instrument the code
        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      AssemblyFilter = [ "Adapter"; "nunit"; "FSharp" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        Actions.ValidateFSharpTypes x [ "main" ]

        printfn "Execute the instrumented tests"

        let sample2 =
            Path.getFullName "./Samples/Sample2/Sample2.fsproj"

        let runner =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0/AltCover.dll"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "net6.0") sample2

        // Run
        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = o
                      CommandLine =
                          args
                          @ [ "/p:AltCoverTag=ReleaseFSharpTypesDotNetRunner_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = runner
              ToolType = dotnetAltcover
              WorkingDirectory = o }
        |> AltCoverCommand.run

        Actions.ValidateFSharpTypesCoverage x)

_Target
    "ReleaseFSharpTypesX86DotNetRunner"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let s = Path.getFullName "."

        let x =
            Path.getFullName "./_Reports/AltCoverReleaseFSharpTypesX86DotNetRunner.xml"

        let o =
            Path.getFullName "./_Binaries/ReleaseFSharpTypesX86DotNetRunner_Sample2/Debug+x86/net6.0"

        let i =
            Path.getFullName "_Binaries/Sample2/Debug+x86/net6.0"

        Shell.cleanDir o

        try
            try
                Environment.SetEnvironmentVariable("platform", "x86")

                DotNet.info
                    (fun o' ->
                        { o' with
                              Common =
                                  { o'.Common with
                                        WorkingDirectory = s
                                        DotNetCliPath = dotnetPath86 |> Option.get } })
                |> printfn "%A"

                printfn "Build the sample2 code as x86"

                "./AltCover.sln"
                |> Path.GetFullPath
                |> DotNet.build
                    (fun p ->
                        { p with
                              Configuration = DotNet.BuildConfiguration.Debug
                              Common =
                                  { p.Common with
                                        WorkingDirectory = s
                                        DotNetCliPath = dotnetPath86 |> Option.get }
                              MSBuildParams = cliArguments })

                printfn "Instrument the code"

                let altcover = unpack @@ "AltCover.dll"

                let prep =
                    AltCover.PrepareOptions.Primitive(
                        { Primitive.PrepareOptions.Create() with
                              Report = x
                              OutputDirectories = [ o ]
                              InputDirectories = [ i ]
                              AssemblyFilter = [ "Adapter"; "nunit"; "FSharp" ]
                              InPlace = false
                              ReportFormat = "NCover"
                              Save = false }
                    )
                    |> AltCoverCommand.Prepare

                { AltCoverCommand.Options.Create prep with
                      ToolPath = altcover
                      ToolType = dotnetAltcover86
                      WorkingDirectory = unpack }
                |> AltCoverCommand.run

                Actions.ValidateFSharpTypes x [ "main" ]
                printfn "Execute the instrumented tests"

                let sample2 =
                    Path.getFullName "./Samples/Sample2/Sample2.fsproj"

                // Run
                let (dotnetexe, args) =
                    defaultDotNetTestCommandLine86 (Some "net6.0") sample2

                let collect =
                    AltCover.CollectOptions.Primitive
                        { Primitive.CollectOptions.Create() with
                              Executable = dotnetexe
                              RecorderDirectory = o
                              CommandLine =
                                  args
                                  @ [ "/p:AltCoverTag=ReleaseFSharpTypesX86DotNetRunner_" ] }
                    |> AltCoverCommand.Collect

                { AltCoverCommand.Options.Create collect with
                      ToolPath = altcover
                      ToolType = dotnetAltcover86
                      WorkingDirectory = o }
                |> AltCoverCommand.run

                Actions.ValidateFSharpTypesCoverage x
            with
            | x ->
                printfn "Failed with %A" x
                reraise ()
        finally
            Environment.SetEnvironmentVariable("platform", ""))

_Target
    "ReleaseXUnitFSharpTypesDotNetRunner"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let x =
            Path.getFullName "./_Reports/ReleaseXUnitFSharpTypesDotNetRunner.xml"

        let o =
            Path.getFullName "./_Binaries/ReleaseXUnitFSharpTypesDotNetRunner_Sample4/Debug+AnyCPU/netcoreapp2.1"

        let i =
            Path.getFullName "_Binaries/Sample4/Debug+AnyCPU/netcoreapp2.1"

        Shell.cleanDir o

        // Instrument the code
        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      AssemblyFilter = [ "xunit" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        Actions.ValidateFSharpTypes x [ "main" ]

        printfn "Execute the instrumented tests"

        let sample4 =
            Path.getFullName "./Samples/Sample4/Sample4.fsproj"

        let runner =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0/AltCover.dll"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "netcoreapp2.1") sample4

        // Run
        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = o
                      CommandLine =
                          args
                          @ [ "/p:AltCoverTag=ReleaseXUnitFSharpTypesDotNetRunner_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = runner
              ToolType = dotnetAltcover
              WorkingDirectory = o }
        |> AltCoverCommand.run

        Actions.ValidateFSharpTypesCoverage x)

_Target
    "OpenCoverForPester"
    (fun _ ->
        Directory.ensure "./_Reports"

        let reportDir =
            Path.getFullName "./_Reports/OpenCoverForPester"

        Directory.ensure reportDir

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let x =
            Path.getFullName "./_Reports/OpenCoverForPester/OpenCoverForPester.xml"

        let o =
            Path.getFullName "./_Binaries/OpenCoverForPester_Sample18/Debug+AnyCPU/net6.0"

        let i =
            Path.getFullName "_Binaries/Sample18/Debug+AnyCPU/net6.0"

        Shell.cleanDir o

        // Instrument the code
        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      AssemblyFilter = [ "xunit"; "FSharp" ]
                      InPlace = false
                      ReportFormat = "OpenCover"
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        printfn "Execute the instrumented tests"

        let sample =
            Path.getFullName "./Samples/Sample18/Sample18.fsproj"

        let runner =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0/AltCover.dll"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "net6.0") sample

        // Run
        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = o
                      CommandLine = args @ [ "/p:AltCoverTag=OpenCoverForPester_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = runner
              ToolType = dotnetAltcover
              WorkingDirectory = o }
        |> AltCoverCommand.run

        // now do it for coverlet
        let report =
            (Path.getFullName "./_Reports")
            @@ "Coverlet_OpenCoverForPester"

        let tr = report @@ "TestResults"
        Directory.ensure tr
        Shell.cleanDir tr

        try
            DotNet.build
                (fun p ->
                    { p.WithCommon dotnetOptions with
                          Configuration = DotNet.BuildConfiguration.Debug }
                    |> (buildWithCLITaggedArguments "CoverletForPester"))
                sample

            DotNet.test (coverletTestOptionsSample tr "CoverletForPester") sample
        with
        | x -> eprintf "%A" x

        let covxml =
            (!!(tr @@ "*/coverage.opencover.xml") |> Seq.head)
            |> Path.getFullName

        let target =
            reportDir @@ "OpenCoverForPester.coverlet.xml"

        Shell.copyFile target covxml

        let binary =
            "_Binaries/CoverletForPester_Sample18/Debug+AnyCPU/net6.0/Sample18.dll"

        let binaryTarget = reportDir @@ "Sample18.dll"
        Shell.copyFile binaryTarget binary

        let binary2 =
            "_Binaries/CoverletForPester_Sample18/Debug+AnyCPU/net6.0/Sample18.pdb"

        let binary2Target = reportDir @@ "Sample18.pdb"
        Shell.copyFile binary2Target binary2)

_Target
    "ReleaseXUnitFSharpTypesShowVisualized"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let x =
            Path.getFullName "./_Reports/ShowStatic.xml"

        let x1 =
            Path.getFullName "./_Reports/ShowStaticPP.xml"

        let x2 =
            Path.getFullName "./_Reports/ShowGenerated.xml"

        let x3 =
            Path.getFullName "./_Reports/ShowGeneratedRun.xml"

        let o =
            Path.getFullName "./_Binaries/ReleaseXUnitFSharpTypesShowVisualized_Sample4/Debug+AnyCPU/netcoreapp2.1"

        let i =
            Path.getFullName "_Binaries/Sample4/Debug+AnyCPU/netcoreapp2.1"

        Shell.cleanDir o

        // Instrument the code
        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      AssemblyFilter = [ "xunit" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false
                      ShowStatic = "+" }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        do
            use coverageFile =
                new FileStream(x, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)
            // Edit xml report to store new hits
            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let vcs =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get "visitcount").Value |> int)
                |> Seq.groupBy id
                |> Seq.sortBy fst
                |> Seq.toList

            printfn "%A" vcs
            printfn "%A" (vcs |> List.map (snd >> Seq.length))
            Assert.That(vcs |> List.map fst, Is.EqualTo [ -3; 0 ], "-3 or 0 only")
            Assert.That(vcs |> List.map (snd >> Seq.length), Is.EqualTo [ 18; 27 ], "10 and 28")

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x1
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      AssemblyFilter = [ "xunit" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false
                      ShowStatic = "++" }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        do
            use coverageFile =
                new FileStream(x1, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)
            // Edit xml report to store new hits
            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let vcs =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get "visitcount").Value |> int)
                |> Seq.groupBy id
                |> Seq.sortBy fst
                |> Seq.toList

            printfn "%A" vcs
            printfn "%A" (vcs |> List.map (snd >> Seq.length))
            Assert.That(vcs |> List.map fst, Is.EqualTo [ 0 ])
            Assert.That(vcs |> List.map (snd >> Seq.length), Is.EqualTo [ 45 ])

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x2
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      AssemblyFilter = [ "xunit" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false
                      ShowGenerated = true }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        do
            use coverageFile =
                new FileStream(x2, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)
            // Edit xml report to store new hits
            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let vcs =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get "visitcount").Value |> int)
                |> Seq.groupBy id
                |> Seq.sortBy fst
                |> Seq.toList

            printfn "%A" vcs
            printfn "%A" (vcs |> List.map (snd >> Seq.length))
            Assert.That(vcs |> List.map fst, Is.EqualTo [ -2; 0 ], "Expect -2, 0")
            Assert.That(vcs |> List.map (snd >> Seq.length), Is.EqualTo [ 6; 21 ], "Expect 6, 21")

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x3
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      AssemblyFilter = [ "xunit" ]
                      InPlace = false
                      ReportFormat = "NCover"
                      Save = false
                      ShowGenerated = true }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        printfn "Execute the instrumented tests"

        let sample4 =
            Path.getFullName "./Samples/Sample4/Sample4.fsproj"

        let runner =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0/AltCover.dll"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "netcoreapp2.1") sample4

        // Run
        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = o
                      CommandLine =
                          args
                          @ [ "/p:AltCoverTag=ReleaseXUnitFSharpTypesShowVisualized_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = runner
              ToolType = dotnetAltcover
              WorkingDirectory = o }
        |> AltCoverCommand.run

        do
            use coverageFile =
                new FileStream(x3, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)
            // Edit xml report to store new hits
            let coverageDocument =
                XDocument.Load(XmlReader.Create(coverageFile))

            let vcs =
                coverageDocument.Descendants(XName.Get("seqpnt"))
                |> Seq.map (fun x -> x.Attribute(XName.Get "visitcount").Value |> int)
                |> Seq.groupBy id
                |> Seq.sortBy fst
                |> Seq.toList

            printfn "%A" vcs
            printfn "%A" (vcs |> List.map (snd >> Seq.length))
            Assert.That(vcs |> List.map fst, Is.EqualTo [ -2; 0; 1; 2 ], "expect [ -2; 0; 1; 2]")
            Assert.That(vcs |> List.map (snd >> Seq.length), Is.EqualTo [ 3; 12; 11; 1 ], "expect [3 ; 12; 11; 1]"))

_Target
    "ReleaseXUnitFSharpTypesDotNetFullRunner"
    (fun _ ->
        Directory.ensure "./_Reports"

        let unpack =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0"

        let x =
            Path.getFullName "./_Reports/ReleaseXUnitFSharpTypesDotNetFullRunner.xml"

        let o =
            Path.getFullName "./_Binaries/ReleaseXUnitFSharpTypesDotNetFullRunner_Sample4/Debug+AnyCPU/netcoreapp2.1"

        let i =
            Path.getFullName "_Binaries/Sample4/Debug+AnyCPU/netcoreapp2.1"

        Shell.cleanDir o
        let before = Actions.ticksNow ()

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      CallContext = [ "0"; "[Fact]" ]
                      AssemblyFilter = [ "xunit" ]
                      InPlace = false
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = "AltCover.dll"
              ToolType = dotnetAltcover
              WorkingDirectory = unpack }
        |> AltCoverCommand.run

        Actions.CheckSample4Content x

        printfn "Execute the instrumented tests"

        let sample4 =
            Path.getFullName "./Samples/Sample4/Sample4.fsproj"

        let runner =
            Path.getFullName "_Packaging/Unpack/tools/netcoreapp2.0/AltCover.dll"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "netcoreapp2.1") sample4

        // Run
        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = o
                      CommandLine =
                          args
                          @ [ "/p:AltCoverTag=ReleaseXUnitFSharpTypesDotNetFullRunner_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = runner
              ToolType = dotnetAltcover
              WorkingDirectory = o }
        |> AltCoverCommand.run

        Actions.CheckSample4Visits before x)

_Target
    "JsonReporting"
    (fun _ ->
        Directory.ensure "./_Reports"

        let runner =
            Path.getFullName "_Packaging/Unpack/tools/net472/AltCover.exe"

        let x =
            Path.getFullName "./_Reports/JsonReporting.json"

        let o =
            Path.getFullName "./_Binaries/JsonReporting_Sample4/Debug+AnyCPU/netcoreapp2.1"

        let i =
            Path.getFullName "_Binaries/Sample4/Debug+AnyCPU/netcoreapp2.1"

        // Test data gathering only
        //let x = Path.getFullName "./AltCover.Tests/Sample5.native.json"
        //let o = Path.getFullName "./_Binaries/JsonReporting_Sample5/Debug+AnyCPU/netstandard2.0"
        //let i = Path.getFullName "_Binaries/Sample5/Debug+AnyCPU/netstandard2.0"

        Shell.cleanDir o
        let before = Actions.ticksNow ()

        let prep =
            AltCover.PrepareOptions.Primitive(
                { Primitive.PrepareOptions.Create() with
                      Report = x
                      //  ZipFile = true
                      ReportFormat = "Json"
                      OutputDirectories = [ o ]
                      InputDirectories = [ i ]
                      CallContext = [ "0"; "[Fact]" ]
                      AssemblyFilter = [ "xunit" ]
                      InPlace = false
                      Save = false }
            )
            |> AltCoverCommand.Prepare

        { AltCoverCommand.Options.Create prep with
              ToolPath = runner
              ToolType = frameworkAltcover
              WorkingDirectory = i }
        |> AltCoverCommand.run

        let checkSample4Content path =
            let coverageDocument =
                path
                |> File.ReadAllText
                |> System.Text.Json.JsonSerializer.Deserialize<AltCover.NativeJson.Modules>

            let recorded =
                coverageDocument.Values
                |> Seq.collect (fun d -> d.Values)
                |> Seq.collect (fun c -> c.Values)
                |> Seq.collect (fun m -> m.Keys)
                |> Seq.sort
                |> Seq.toList

            let expected =
                [ "Microsoft.FSharp.Core.FSharpFunc`2<Microsoft.FSharp.Core.Unit,Tests.DU/MyUnion> Tests.DU/MyUnion::get_MyBar()"
                  "System.Byte[] Tests.M/Thing::bytes()"
                  "System.Int32 Tests.Program::main(System.String[])"
                  "System.Void Tests.DU/MyClass::.ctor()"
                  "System.Void Tests.DU::testMakeUnion()"
                  "System.Void Tests.M::testMakeThing()"
                  "Tests.DU/MyUnion Tests.DU/MyUnion::as_bar()"
                  "Tests.DU/MyUnion Tests.DU::returnBar(System.String)"
                  "Tests.DU/MyUnion Tests.DU::returnFoo(System.Int32)"
                  "Tests.M/Thing Tests.M::makeThing(System.String)" ]

            Assert.That(recorded, expected |> Is.EqualTo, sprintf "Bad method list %A" recorded)
            printfn "Content OK"

        // printfn "Extract and verify the first results"
        // Shell.cleanDir "./_Reports/JsonReporting2"
        // System.IO.Compression.ZipFile.ExtractToDirectory(x + ".zip", "./_Reports/JsonReporting1")
        // checkSample4Content "./_Reports/JsonReporting1/JsonReporting.json"

        checkSample4Content x

        printfn "Execute the instrumented tests"

        let sample4 =
            Path.getFullName "./Samples/Sample4/Sample4.fsproj"

        let runner =
            Path.getFullName "_Packaging/Unpack/tools/net472/AltCover.exe"

        let (dotnetexe, args) =
            defaultDotNetTestCommandLine (Some "netcoreapp2.1") sample4

        // Run
        let collect =
            AltCover.CollectOptions.Primitive
                { Primitive.CollectOptions.Create() with
                      Executable = dotnetexe
                      RecorderDirectory = o
                      CommandLine = args @ [ "/p:AltCoverTag=JsonReporting_" ] }
            |> AltCoverCommand.Collect

        { AltCoverCommand.Options.Create collect with
              ToolPath = runner
              ToolType = frameworkAltcover
              WorkingDirectory = o }
        |> AltCoverCommand.run

        let checkSample4Visits from path =
            let coverageDocument =
                path
                |> File.ReadAllText
                |> System.Text.Json.JsonSerializer.Deserialize<AltCover.NativeJson.Modules>

            let recorded =
                coverageDocument.Values
                |> Seq.collect (fun d -> d.Values)
                |> Seq.collect (fun c -> c.Values)
                |> Seq.collect (fun m -> m.Values)
                |> Seq.collect (fun m -> m.SeqPnts)
                |> Seq.map (fun s -> s.VC)
                |> Seq.toList

            let expected =
                "0 1 1 0 1 0 1 0 1 0 0 0 0 0 1 1 1 0 0 0 0 2 0 1 0 1 1"
            //"0 1 1 0 1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 2 0 1 0 1 1"

            Assert.That(String.Join(" ", recorded), expected |> Is.EqualTo, sprintf "Bad visit list %A" recorded)
            printfn "Visits OK"

            let methods =
                coverageDocument.Values
                |> Seq.collect (fun d -> d.Values)
                |> Seq.collect (fun c -> c.Values)
                |> Seq.collect id
                |> Seq.toList

            let trackedFormat =
                methods
                |> List.filter (fun m -> m.Value.TId.HasValue)
                |> List.map (fun m -> m.Key, m.Value.TId.Value)
                |> List.sortBy snd
                |> List.map (sprintf "%A")

            Assert.That(
                String.Join(" ", trackedFormat),
                """("System.Void Tests.DU::testMakeUnion()", 1) ("System.Void Tests.M::testMakeThing()", 2)"""
                |> Is.EqualTo,
                sprintf "Bad tracked method list %A" trackedFormat
            )

            //let trackedTimes =
            methods
            |> List.filter (fun m -> m.Value.TId.HasValue)
            //                        |> List.collect (fun m -> let first = m.Value.Entry
            |> List.iter
                (fun m ->
                    let first =
                        m.Value.Entry
                        |> Seq.head
                        |> Convert.FromBase64String
                        |> (fun x -> BitConverter.ToInt64(x, 0))
                        |> System.Net.IPAddress.NetworkToHostOrder

                    let second =
                        m.Value.Exit
                        |> Seq.head
                        |> Convert.FromBase64String
                        |> (fun x -> BitConverter.ToInt64(x, 0))
                        |> System.Net.IPAddress.NetworkToHostOrder

                    test <@ from <= first @>
                    test <@ first <= second @>
                    test <@ second <= Actions.ticksNow () @>)
            //                                                  [first; second])
            //  Assert.That
            //    (x.ToString().Replace("\r\n", "\n"),
            //     Is.EqualTo <| tracked.Replace("\r\n", "\n"))) ???
            printfn "Tracked OK"

            let trackedVisits =
                coverageDocument.Values
                |> Seq.collect (fun d -> d.Values)
                |> Seq.collect (fun c -> c.Values)
                |> Seq.collect (fun m -> m.Values)
                |> Seq.collect (fun m -> m.SeqPnts)
                |> Seq.filter (fun s -> s.Tracks |> isNull |> not)
                |> Seq.collect (fun s -> s.Tracks)
                |> Seq.map (fun i -> i.ToString(System.Globalization.CultureInfo.InvariantCulture))
                |> Seq.toList

            Assert.That(
                String.Join(" ", trackedVisits),
                "1 1 1 1 1 1 1 1 2 2 2 2 2" |> Is.EqualTo,
                //"1 1 1 1 1 1 1 2 2 2 2 2" |> Is.EqualTo,
                sprintf "Bad tracked visit list %A" trackedVisits
            )

            printfn "TrackRefs OK"

        // printfn "Extract and verify the final results"
        // Shell.cleanDir "./_Reports/JsonReporting1"
        // System.IO.Compression.ZipFile.ExtractToDirectory(x + ".zip", "./_Reports/JsonReporting2")
        // checkSample4Visits before "./_Reports/JsonReporting2/JsonReporting.json"

        checkSample4Visits before x)

_Target
    "MSBuildTest"
    (fun _ ->
        Directory.ensure "./_Reports"
        let build = Path.getFullName "Build"
        let sample = Path.getFullName "Samples/Sample4"

        let x =
            Path.getFullName "./_Reports/MSBuildTest.xml"

        // Run
        let before = Actions.ticksNow ()
        Shell.cleanDir ("./_Binaries/MSBuildTest_Sample4LongForm")
        Shell.cleanDir ("./_Binaries/MSBuildTest_Sample4")

        DotNet.msbuild
            (fun opt ->
                let tmp =
                    opt.WithCommon
                        (fun o' ->
                            { dotnetOptions o' with
                                  WorkingDirectory = sample })

                let mparams =
                    { tmp.MSBuildParams with
                          Properties =
                              ("AltCoverTag", "MSBuildTest_")
                              :: tmp.MSBuildParams.Properties }

                { tmp with MSBuildParams = mparams })
            (build @@ "msbuildtest.proj")

        printfn "Checking samples4 output"
        Actions.CheckSample4 before x

        // touch-test framework
        let unpack =
            match NuGetAltCover with
            | Some test ->
                Trace.traceImportant "Using the NuGet package"
                Path.GetDirectoryName test
            | _ -> Path.getFullName "_Packaging/Unpack/tools/net472"

        MSBuild.build
            (fun p ->
                { p with
                      Verbosity = Some MSBuildVerbosity.Minimal
                      Properties =
                          [ "Configuration", "Debug"
                            "MSBuildTest", "true"
                            "AltCoverTag", "MSBuildTest_"
                            "AltCoverPath", unpack.Replace('\\', '/')
                            "DebugSymbols", "True" ] })
            "./Samples/Sample4/Sample4LongForm.fsproj")

_Target
    "Cake1Test"
    (fun _ ->
        let before = Actions.ticksNow ()

        try
            Directory.ensure "./_Cake"
            Shell.cleanDir "./_Cake"
            Directory.ensure "./_Binaries/cake_dotnettest"
            Shell.cleanDir "./_Binaries/cake_dotnettest"
            Directory.ensure "./_Cake/_DotnetTest"

            let config =
                XDocument.Load "./Build/NuGet.config.dotnettest"

            let repo =
                config.Descendants(XName.Get("add")) |> Seq.head

            repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
            config.Save "./_Cake/_DotnetTest/NuGet.config"

            let fsproj =
                XDocument.Load "./Samples/Sample4/Sample4.fsproj"

            let targets =
                fsproj.Descendants(XName.Get("TargetFrameworks"))
                |> Seq.head

            targets.SetValue "net6.0"

            let pack =
                fsproj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover.api"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject

            fsproj.Save "./_Cake/_DotnetTest/cake_dotnettest.fsproj"

            Shell.copy "./_Cake/_DotnetTest" (!! "./Samples/Sample4/*.fs")
            Shell.copy "./_Cake/_DotnetTest" (!! "./Samples/Sample4/*.json")
            Shell.copyDir "./_Cake/_DotnetTest/Data" "./Samples/Sample4/Data" File.Exists

            let config =
                """<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="local" value="{0}" />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
</configuration>"""

            File.WriteAllText("./_Cake/NuGet.config", String.Format(config, Path.getFullName "./_Packaging.api"))

            let script = File.ReadAllText("./Build/build.cake")

            File.WriteAllText(
                "./_Cake/build.cake",
                script
                    .Replace(
                        "{0}",
                        (Path.getFullName "./_Packaging.api")
                            .Replace("\\", "/")
                    )
                    .Replace("{1}", Version.Value)
            )

            let script2= File.ReadAllText("./Build/build2.cake")
            File.WriteAllText(
                "./_Cake/build2.cake",
                script2)

            [ (" --version 1.3.0", "build.cake")
              (String.Empty, "build.cake")
              (String.Empty, "build2.cake")]
            |> List.iter
                (fun (cakeversion, script) ->
                    try
                        Actions.RunDotnet
                            (fun o' ->
                                { dotnetOptions o' with
                                      WorkingDirectory = "./_Cake" })
                            "tool"
                            ("install -g cake.tool" + cakeversion)
                            "Installed"

                        let cv =
                            if String.IsNullOrWhiteSpace cakeversion then
                                "Latest"
                            else
                                cakeversion.Trim()

                        Actions.RunDotnet
                            (fun o' ->
                                { dotnetOptions o' with
                                      WorkingDirectory = "./_Cake" })
                            "tool"
                            ("list -g ")
                            "Checked"

                        Actions.RunDotnet
                            (withWorkingDirectoryOnly "_Cake")
                            "cake"
                            (script + " --rebuild=true \"--cakeversion="
                             + cv
                             + "\"")
                            "running cake script returned with a non-zero exit code"

                        let x =
                            Path.getFullName (
                                "./_Cake/_DotnetTest/coverage."
                                + script + "."
                                + cv
                                + ".net6.0.xml"
                            )

                        Actions.CheckSample4 before x
                    finally
                        Actions.RunDotnet
                            (fun o' ->
                                { dotnetOptions o' with
                                      WorkingDirectory = "./_Cake" })
                            "tool"
                            ("uninstall -g cake.tool")
                            "uninstalled")
        finally
            [ "altcover.api" ]
            |> List.iter
                (fun f ->
                    let folder = (nugetCache @@ f) @@ Version.Value
                    Shell.mkdir folder
                    Actions.CleanDir folder))

_Target
    "ApiUse"
    (fun _ ->
        let before = Actions.ticksNow ()

        try
            Directory.ensure "./_ApiUse"
            Shell.cleanDir ("./_ApiUse")
            Directory.ensure "./_ApiUse/_DotnetTest"

            let apiroot = Path.GetFullPath "./_Packaging.api"
            let fakeroot = Path.GetFullPath "./_Packaging.fake"

            if "./Build/paket.lock" |> File.Exists then
                // manage the dependencies
                let lines =
                    "./Build/paket.lock"
                    |> File.ReadAllLines
                    |> Array.map (fun line -> String.Format(line, !Version, apiroot, fakeroot))

                File.WriteAllLines("./_ApiUse/paket.lock", lines)

            let config =
                XDocument.Load "./Build/NuGet.config.dotnettest"

            let repo =
                config.Descendants(XName.Get("add")) |> Seq.head

            repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
            config.Save "./_ApiUse/_DotnetTest/NuGet.config"

            let fsproj =
                XDocument.Load "./Samples/Sample4/Sample4.fsproj"

            let targets =
                fsproj.Descendants(XName.Get("TargetFrameworks"))
                |> Seq.head

            targets.SetValue "netcoreapp2.1"

            let pack =
                fsproj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover.api"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            fsproj.Save "./_ApiUse/_DotnetTest/apiuse_dotnettest.fsproj"
            Shell.copy "./_ApiUse/_DotnetTest" (!! "./Samples/Sample4/*.fs")
            Shell.copy "./_ApiUse/_DotnetTest" (!! "./Samples/Sample4/*.json")
            Shell.copyDir "./_ApiUse/_DotnetTest/Data" "./Samples/Sample4/Data" File.Exists

            let config =
                """<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="local" value="{0}" />
    <add key="local2" value="{1}" />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
</configuration>"""

            File.WriteAllText(
                "./_ApiUse/NuGet.config",
                String.Format(config, Path.getFullName "./_Packaging.api", Path.getFullName "./_Packaging.fake")
            )

            let script =
                """#r "paket: groupref netcorebuild //"
#load ".fake/DriveApi.fsx/intellisense.fsx"

open System
open Fake.IO
open Fake.Core
open Fake.DotNet
open Fake.IO
open Fake.IO.FileSystemOperators
open Fake.IO.Globbing
open Fake.IO.Globbing.Operators

open AltCover.Fake.DotNet // extension methods

let _Target s f =
  Target.description s
  Target.create s f

_Target "DoIt"
  (fun _ ->
  let expected = {0}
  let acv = AltCover.Command.Version()
  printfn "AltCover.Command.Version - Returned %A expected %A" acv expected
  if acv.ToString() <> expected
  then failwith "AltCover.Command.Version mismatch"

  let acfv = AltCover.Command.FormattedVersion()
  printfn "AltCover.Command.FormattedVersion - Returned '%s' expected %A" acfv expected
  if acfv <> (sprintf "AltCover version %s" expected)
  then failwith "AltCover.Command.FormattedVersion mismatch"

  let afcv = AltCover.Fake.Command.Version().ToString()
  afcv |> Trace.trace
  printfn "expected %A" expected
  if afcv.ToString() <> expected
  then failwith "AltCover.Fake.Command.Version mismatch"

  let collect =
    AltCover.AltCover.CollectOptions.Primitive
      { AltCover.Primitive.CollectOptions.Create() with LcovReport = "x" }
  let prepare =
    AltCover.AltCover.PrepareOptions.Primitive
      { AltCover.Primitive.PrepareOptions.Create() with TypeFilter = [| "a"; "b" |] }
  let ForceTrue = AltCover.DotNet.CLIOptions.Force true
  printfn "Test arguments : '%s'" (AltCover.DotNet.ToTestArguments prepare collect ForceTrue)

  let t = DotNet.TestOptions.Create().WithAltCoverOptions prepare collect ForceTrue
  printfn "WithAltCoverOptions returned '%A'" t.Common.CustomParams

  let p2 =
    { AltCover.Primitive.PrepareOptions.Create() with
        CallContext = [| "[Fact]"; "0" |]
        AssemblyFilter = [| "xunit" |] }

  let pp2 = AltCover.AltCover.PrepareOptions.Primitive p2
  let c2 = AltCover.Primitive.CollectOptions.Create()
  let cc2 = AltCover.AltCover.CollectOptions.Primitive c2

  let setBaseOptions (o: DotNet.Options) =
    { o with
        WorkingDirectory = Path.getFullName "./_DotnetTest"
        Verbosity = Some DotNet.Verbosity.Minimal }

  let cliArguments =
    { MSBuild.CliArguments.Create() with
        ConsoleLogParameters = []
        DistributedLoggers = None
        Properties = []
        DisableInternalBinLog = true }

  DotNet.test
    (fun to' ->
    { to'.WithCommon(setBaseOptions).WithAltCoverOptions pp2 cc2 ForceTrue with
        MSBuildParams = cliArguments }) "apiuse_dotnettest.fsproj"
  let ImportModule =
    (AltCover.Command.ImportModule().Trim().Split()
     |> Seq.take 2
     |> Seq.skip 1
     |> Seq.head).Trim([| '"' |])

  let command = "$ImportModule = '" + ImportModule + "'; Import-Module $ImportModule; ConvertTo-BarChart -?"

  let corePath = AltCover.Fake.Command.ToolPath AltCover.Fake.Implementation.DotNetCore
  printfn "corePath = %A" corePath
  let frameworkPath = AltCover.Fake.Command.ToolPath AltCover.Fake.Implementation.Framework
  printfn "frameworkPath = %A" frameworkPath

  if frameworkPath |> String.IsNullOrEmpty |> not
  then
    let framework = Fake.DotNet.ToolType.CreateFullFramework()

    { AltCoverFake.DotNet.Testing.AltCoverCommand.Options.Create
        AltCoverFake.DotNet.Testing.AltCoverCommand.ArgumentType.GetVersion
          with
            ToolType = framework
            ToolPath = frameworkPath }
    |> AltCoverFake.DotNet.Testing.AltCoverCommand.run

  let core = Fake.DotNet.ToolType.CreateFrameworkDependentDeployment id

  { AltCoverFake.DotNet.Testing.AltCoverCommand.Options.Create
      AltCoverFake.DotNet.Testing.AltCoverCommand.ArgumentType.GetVersion
        with
          ToolType = core
          ToolPath = corePath }
  |> AltCoverFake.DotNet.Testing.AltCoverCommand.run

  let pwsh =
    if Environment.isWindows then
      Fake.Core.ProcessUtils.findLocalTool String.Empty "pwsh.exe"
        [ Environment.environVar "ProgramFiles" @@ "PowerShell" ]
    else "pwsh"

  let r =
    CreateProcess.fromRawCommand pwsh [ "-NoProfile"; "-Command"; command ]
    |> CreateProcess.withWorkingDirectory "."
    |> Proc.run

  if (r.ExitCode <> 0) then new InvalidOperationException("Non zero return code") |> raise)
Target.runOrDefault "DoIt"
"""

            let vv = Version.Value + "-"
            let ver = vv.Split([| '-' |]) |> Seq.head

            File.WriteAllText("./_ApiUse/DriveApi.fsx", script.Replace("{0}", "\"" + ver + "\""))

            let dependencies =
                """version 6.2.1
// [ FAKE GROUP ]
group NetcoreBuild
  storage: none
  source https://api.nuget.org/v3/index.json
  nuget FSharp.Core = 6.0.1
  nuget Fake.Core.Target >= 5.21.0
  nuget Fake.DotNet.Cli >= 5.21.0
  source {0}
  nuget AltCover.Api {1}
  source {2}
  nuget AltCover.Fake {1} """

            File.WriteAllText(
                "./_ApiUse/paket.dependencies",
                String.Format(
                    dependencies,
                    Path.getFullName "./_Packaging.api",
                    Version.Value,
                    Path.getFullName "./_Packaging.fake"
                )
            )

            Actions.RunDotnet
                (withWorkingDirectoryOnly "_ApiUse")
                "fake"
                "run ./DriveApi.fsx" // "-v run ./DriveApi.fsx" for verbose mode
                "running fake script returned with a non-zero exit code"

            let x =
                Path.getFullName "./_ApiUse/_DotnetTest/coverage.netcoreapp2.1.xml"

            Actions.CheckSample4 before x
        finally
            [ "altcover"
              "altcover.api"
              "altcover.fake" ]
            |> List.iter
                (fun f ->
                    let folder = (nugetCache @@ f) @@ Version.Value
                    Shell.mkdir folder
                    Actions.CleanDir folder))

_Target
    "DotnetTestIntegration"
    (fun _ ->
        let assertFile f = Assert.That(File.Exists f, f)

        let assertCopied p =
            [ "Data/Bar.txt"
              "Data/Foo.txt"
              "Data/Deeper/Bar.txt"
              "Data/Deeper/Foo.txt" ]
            |> Seq.iter (fun f -> assertFile (p @@ f))

        try
            printfn "Initializing ------------------------------------------------"

            [ ("./_DotnetTest", "Sample4", "fsproj")
              ("./_DotnetTestJson", "Sample4", "fsproj")
              ("./_DotnetTestFail", "Sample13", "fsproj")
              ("./_DotnetTestFailFast", "Sample13", "fsproj")
              ("./_DotnetTestFailInstrumentation", "Sample13", "fsproj")
              ("./_DotnetTestLineCoverInPlace", "Sample10", "csproj")
              ("./_DotnetTestBranchCoverInPlace", "Sample10", "csproj")
              ("./_DotnetTestInPlace", "Sample4", "fsproj")
              ("./_DotnetTestFailInPlace", "Sample13", "fsproj")
              ("./_DotnetTestFailFastInPlace", "Sample13", "fsproj")
              ("./_DotnetTestFailInstrumentationInPlace", "Sample13", "fsproj")
              ("./_DotnetTestLineCover", "Sample10", "csproj")
              ("./_DotnetTestBranchCover", "Sample10", "csproj") ]
            |> List.iter
                (fun (d, p, t) ->
                    Directory.ensure d
                    Shell.cleanDir d

                    let config =
                        XDocument.Load "./Build/NuGet.config.dotnettest"

                    let repo =
                        config.Descendants(XName.Get("add")) |> Seq.head

                    repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
                    config.Save(d @@ "NuGet.config")

                    let projpath = "./Samples/" + p + "/" + p + "." + t
                    printfn "%s -> %s" d projpath

                    let fsproj = XDocument.Load projpath

                    let targets =
                        [ fsproj.Descendants(XName.Get("TargetFrameworks"))
                          fsproj.Descendants(XName.Get("TargetFramework")) ]
                        |> Seq.concat
                        |> Seq.head

                    targets.SetValue "net6.0"
                    targets.AddAfterSelf(XElement(XName.Get "DocumentationFile"))

                    fsproj.Descendants(XName.Get("HintPath"))
                    |> Seq.iter
                        (fun hint ->
                            "ThirdParty/Unquote.dll"
                            |> Path.getFullName
                            |> hint.SetValue)

                    let pack =
                        fsproj.Descendants(XName.Get("PackageReference"))
                        |> Seq.head

                    let inject =
                        XElement(
                            XName.Get "PackageReference",
                            XAttribute(XName.Get "Include", "altcover"),
                            XAttribute(XName.Get "Version", Version.Value)
                        )

                    pack.AddBeforeSelf inject
                    let projName = d.Substring(2)
                    fsproj.Save(d + "/" + projName + "." + t)
                    Shell.copy d !!("./Samples/" + p + "/*." + t.Substring(0, 2))
                    Shell.copy d !!("./Samples/" + p + "/*.json")

                    let data = "./Samples/" + p + "/Data"

                    if Directory.Exists data then
                        Shell.copyDir (d @@ "Data") data File.Exists)

            printfn "Simple positive case ------------------------------------------------"

            let before = Actions.ticksNow ()
            let p0 = Primitive.PrepareOptions.Create()
            let c0 = Primitive.CollectOptions.Create()
            let asInPlace (p: Primitive.PrepareOptions) = { p with InPlace = true }
            let asJson (p: Primitive.PrepareOptions) = { p with ReportFormat = "Json" }
            let p0a = asInPlace p0

            let p1 =
                { p0 with
                      CallContext = [ "[Fact]"; "0" ]
                      AssemblyFilter = [| "xunit"; "FSharp"; "Monitor" |] }

            let pp1 = AltCover.PrepareOptions.Primitive p1

            let pp1a =
                AltCover.PrepareOptions.Primitive(asInPlace p1)

            let pp1b =
                AltCover.PrepareOptions.Primitive(asJson p1)

            let cc0 =
                AltCover.CollectOptions.Primitive { c0 with SummaryFormat = "+B" }

            DotNet.test
                (fun to' ->
                    (to'
                        .WithCommon(withWorkingDirectoryVM "_DotnetTest")
                        .WithAltCoverGetVersion()
                        .WithAltCoverImportModule())
                        .WithAltCoverOptions
                        pp1
                        cc0
                        ForceTrue
                    |> testWithCLIArguments)
                "_DotnetTest.fsproj"

            assertCopied ("_Binaries/_DotnetTest/Debug+AnyCPU/net6.0/__Instrumented__DotnetTest")

            DotNet.test
                (fun to' ->
                    (to'
                        .WithCommon(withWorkingDirectoryVM "_DotnetTestJson")
                        .WithAltCoverGetVersion()
                        .WithAltCoverImportModule())
                        .WithAltCoverOptions
                        pp1b
                        cc0
                        ForceTrue
                    |> testWithCLIArguments)
                "_DotnetTestJson.fsproj" // TODO validate output as per JsonReporting

            assertCopied ("_Binaries/_DotnetTestJson/Debug+AnyCPU/net6.0/__Instrumented__DotnetTestJson")

            let x =
                Path.getFullName "./_DotnetTest/coverage.net6.0.xml"

            Actions.CheckSample4 before x

            DotNet.test
                (fun to' ->
                    (to'
                        .WithCommon(withWorkingDirectoryVM "_DotnetTestInPlace")
                        .WithAltCoverGetVersion()
                        .WithAltCoverImportModule())
                        .WithAltCoverOptions
                        pp1a
                        cc0
                        ForceTrue
                    |> testWithCLIArguments)
                "_DotnetTestInPlace.fsproj"

            let x =
                Path.getFullName "./_DotnetTestInPlace/coverage.net6.0.xml"

            Actions.CheckSample4 before x

            printfn "optest failing instrumentation ------------------------------------------------"

            let xx0 =
                Path.getFullName "./_Reports/nonesuch.xml"

            let xx0a =
                Path.getFullName "./_Reports/nonesuchInPlace.xml"

            let pf0 =
                { p0 with
                      AssemblyFilter = [| "NUnit"; "FSharp"; "Monitor" |]
                      StrongNameKey = "./_Reports/nonesuch.junk"
                      Report = xx0 }
                |> AltCover.PrepareOptions.Primitive

            let pf0a =
                { p0a with
                      AssemblyFilter = [| "NUnit"; "FSharp"; "Monitor" |]
                      StrongNameKey = "./_Reports/nonesuch.junk"
                      Report = xx0a }
                |> AltCover.PrepareOptions.Primitive

            try
                DotNet.test
                    (fun to' ->
                        (to'.WithCommon(withWorkingDirectoryVM "_DotnetTestFailInstrumentation"))
                            .WithAltCoverOptions
                            pf0
                            cc0
                            ForceTrue
                        |> testWithCLIArguments)
                    "_DotnetTestFailInstrumentation.fsproj"

                Assert.Fail("Build exception should be raised")
            with
            | :? Fake.DotNet.MSBuildException -> printfn "Caught expected exception"

            Assert.That(xx0 |> File.Exists |> not, xx0 + " should not be present")

            Assert.That(
                "./_DotnetTestFailInstrumentation/bin/Debug/net6.0/dotnettest.dll.txt"
                |> File.Exists
                |> not,
                "./_DotnetTestFailInstrumentation/bin/Debug/net6.0/dotnettest.dll.txt should not be present"
            )

            try
                DotNet.test
                    (fun to' ->
                        (to'.WithCommon(withWorkingDirectoryVM "_DotnetTestFailInstrumentationInPlace"))
                            .WithAltCoverOptions
                            pf0a
                            cc0
                            ForceTrue
                        |> testWithCLIArguments)
                    "_DotnetTestFailInstrumentationInPlace.fsproj"

                Assert.Fail("Build exception should be raised")
            with
            | :? Fake.DotNet.MSBuildException -> printfn "Caught expected exception"

            Assert.That(xx0a |> File.Exists |> not, xx0a + " should not be present")

            Assert.That(
                "./_DotnetTestFailInstrumentationInPlace/bin/Debug/net6.0/dotnettest.dll.txt"
                |> File.Exists
                |> not,
                "./_DotnetTestFailInstrumentationInPlace/bin/Debug/net6.0/dotnettest.dll.txt should not be present"
            )

            printfn "optest failing test ------------------------------------------------"

            let xx =
                Path.getFullName "./_DotnetTestFail/coverage.xml"

            let xxa =
                Path.getFullName "./_DotnetTestFailInPlace/coverage.xml"

            let pf1 =
                { p0 with
                      AssemblyExcludeFilter = [| "NUnit" |]
                      AssemblyFilter = [| "FSharp"; "Monitor" |] }
                |> AltCover.PrepareOptions.Primitive

            let pf1a =
                { p0a with
                      AssemblyFilter = [| "NUnit"; "FSharp"; "Monitor" |] }
                |> AltCover.PrepareOptions.Primitive

            try
                DotNet.test
                    (fun to' ->
                        (to'.WithCommon(withWorkingDirectoryVM "_DotnetTestFail"))
                            .WithAltCoverOptions
                            pf1
                            cc0
                            ForceTrue
                        |> testWithCLIArguments)
                    "_DotnetTestFail.fsproj"

                Assert.Fail("Build exception should be raised")
            with
            | :? Fake.DotNet.MSBuildException -> printfn "Caught expected exception"

            Assert.That(
                "./_Binaries/_DotnetTestFail/Debug+AnyCPU/net6.0/_DotnetTestFail.dll.txt"
                |> File.Exists,
                "./_Binaries/_DotnetTestFail/Debug+AnyCPU/net6.0/_DotnetTestFail.dll.txt should exist"
            )

            do
                use coverageFile =
                    new FileStream(xx, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                let recorded =
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                    |> Seq.toList

                Assert.That(String.Join(";", recorded), Is.EqualTo "1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;0;1;1;1;1;1;0", xx)

            try
                DotNet.test
                    (fun to' ->
                        (to'.WithCommon(withWorkingDirectoryVM "_DotnetTestFailInPlace"))
                            .WithAltCoverOptions
                            pf1a
                            cc0
                            ForceTrue
                        |> testWithCLIArguments)
                    "_DotnetTestFailInPlace.fsproj"

                Assert.Fail("Build exception should be raised")
            with
            | :? Fake.DotNet.MSBuildException -> printfn "Caught expected exception"

            let filepath =
                Path.GetFullPath "./_Binaries/_DotnetTestFailInPlace/Debug+AnyCPU/net6.0/_DotnetTestFailInPlace.dll.txt"

            Assert.That(filepath |> File.Exists, filepath + " should exist")

            do
                use coverageFile =
                    new FileStream(
                        xxa,
                        FileMode.Open,
                        FileAccess.Read,
                        FileShare.None,
                        4096,
                        FileOptions.SequentialScan
                    )

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                let recorded =
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                    |> Seq.toList

                Assert.That(String.Join(";", recorded), Is.EqualTo "1;1;1;1;1;1;1;1;1;1;1;1;1;0;0;1;1;1;1;1;1;0", xxa)

            printfn "optest failing test fast ------------------------------------------------"

            let xx =
                Path.getFullName "./_DotnetTestFailFast/coverage.xml"

            let xxa =
                Path.getFullName "./_DotnetTestFailFastInPlace/coverage.xml"

            let pf1 =
                { p0 with
                      AssemblyFilter = [| "NUnit"; "FSharp"; "Monitor" |] }
                |> AltCover.PrepareOptions.Primitive

            let pf1a =
                { p0 with
                      AssemblyFilter = [| "NUnit"; "FSharp"; "Monitor" |] }
                |> asInPlace
                |> AltCover.PrepareOptions.Primitive

            try
                DotNet.test
                    (fun to' ->
                        (to'.WithCommon(withWorkingDirectoryVM "_DotnetTestFailFast"))
                            .WithAltCoverOptions
                            pf1
                            cc0
                            FailTrue
                        |> testWithCLIArguments)
                    "_DotnetTestFailFast.fsproj"

                Assert.Fail("Build exception should be raised")
            with
            | :? Fake.DotNet.MSBuildException -> printfn "Caught expected exception"

            Assert.That(
                "./_Binaries/_DotnetTestFailFast/Debug+AnyCPU/net6.0/_DotnetTestFailFast.dll.txt"
                |> File.Exists,
                "./_Binaries/_DotnetTestFailFast/Debug+AnyCPU/net6.0/_DotnetTestFailFast.dll.txt should exist"
            )

            do
                use coverageFile =
                    new FileStream(xx, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                let recorded =
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                    |> Seq.toList

                Assert.That(String.Join(";", recorded), Is.EqualTo "0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0", xx)

            try
                DotNet.test
                    (fun to' ->
                        (to'.WithCommon(withWorkingDirectoryVM "_DotnetTestFailFastInPlace"))
                            .WithAltCoverOptions
                            pf1a
                            cc0
                            FailTrue
                        |> testWithCLIArguments)
                    "_DotnetTestFailFastInPlace.fsproj"

                Assert.Fail("Build exception should be raised")
            with
            | :? Fake.DotNet.MSBuildException -> printfn "Caught expected exception"

            Assert.That(
                "./_Binaries/_DotnetTestFailFastInPlace/Debug+AnyCPU/net6.0/_DotnetTestFailFastInPlace.dll.txt"
                |> File.Exists,
                "./_Binaries/_DotnetTestFailFastInPlace/Debug+AnyCPU/net6.0/_DotnetTestFailFastInPlace.dll.txt should exist"
            )

            do
                use coverageFile =
                    new FileStream(
                        xxa,
                        FileMode.Open,
                        FileAccess.Read,
                        FileShare.None,
                        4096,
                        FileOptions.SequentialScan
                    )

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                let recorded =
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                    |> Seq.toList

                Assert.That(String.Join(";", recorded), Is.EqualTo "0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0", xxa)

            printfn "optest line cover ------------------------------------------------"

            let p2 =
                { p0 with
                      LineCover = true
                      AssemblyFilter = [| "xunit"; "FSharp"; "Monitor" |] }

            let p2a = asInPlace p2

            let pp2a = AltCover.PrepareOptions.Primitive p2a

            DotNet.test
                (fun to' ->
                    to'
                        .WithCommon(
                            withWorkingDirectoryVM "_DotnetTestLineCoverInPlace"
                        )
                        .WithAltCoverOptions
                        pp2a
                        cc0
                        ForceTrue
                    |> testWithCLIArguments)
                ""

            let pp2 = AltCover.PrepareOptions.Primitive p2

            DotNet.test
                (fun to' ->
                    to'
                        .WithCommon(
                            withWorkingDirectoryVM "_DotnetTestLineCover"
                        )
                        .WithAltCoverOptions
                        pp2
                        cc0
                        ForceTrue
                    |> testWithCLIArguments)
                ""

            let x =
                Path.getFullName "./_DotnetTestLineCover/coverage.xml"

            do
                use coverageFile =
                    new FileStream(x, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                Assert.That(
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.length,
                    Is.EqualTo 13,
                    "./_DotnetTestLineCover/coverage.xml"
                )

                Assert.That(
                    coverageDocument.Descendants(XName.Get("BranchPoint"))
                    |> Seq.length,
                    Is.EqualTo 0
                )

            let xa =
                Path.getFullName "./_DotnetTestLineCoverInPlace/coverage.xml"

            do
                use coverageFile =
                    new FileStream(xa, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                Assert.That(
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.length,
                    Is.EqualTo 13,
                    "./_DotnetTestLineCoverInPlace/coverage.xml"
                )

                Assert.That(
                    coverageDocument.Descendants(XName.Get("BranchPoint"))
                    |> Seq.length,
                    Is.EqualTo 0
                )

            printfn "optest branch cover ------------------------------------------------"

            let p3 =
                { p0 with
                      BranchCover = true
                      AssemblyFilter = [| "xunit"; "FSharp"; "Monitor" |] }

            let p3a = asInPlace p3

            let pp3 = AltCover.PrepareOptions.Primitive p3
            let pp3a = AltCover.PrepareOptions.Primitive p3a

            DotNet.test
                (fun to' ->
                    (to'
                        .WithCommon(
                            withWorkingDirectoryVM "_DotnetTestBranchCoverInPlace"
                        )
                         .WithAltCoverOptions
                         pp3a
                         cc0
                         ForceTrue)
                    |> testWithCLIArguments)
                ""

            let x =
                Path.getFullName "./_DotnetTestBranchCoverInPlace/coverage.xml"

            do
                use coverageFile =
                    new FileStream(x, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                Assert.That(
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.length,
                    Is.EqualTo 0
                )

                Assert.That(
                    coverageDocument.Descendants(XName.Get("BranchPoint"))
                    |> Seq.length,
                    Is.EqualTo 2
                )

            DotNet.test
                (fun to' ->
                    (to'
                        .WithCommon(
                            withWorkingDirectoryVM "_DotnetTestBranchCover"
                        )
                         .WithAltCoverOptions
                         pp3
                         cc0
                         ForceTrue)
                    |> testWithCLIArguments)
                ""

            let x =
                Path.getFullName "./_DotnetTestBranchCover/coverage.xml"

            do
                use coverageFile =
                    new FileStream(x, FileMode.Open, FileAccess.Read, FileShare.None, 4096, FileOptions.SequentialScan)

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                Assert.That(
                    coverageDocument.Descendants(XName.Get("SequencePoint"))
                    |> Seq.length,
                    Is.EqualTo 0
                )

                Assert.That(
                    coverageDocument.Descendants(XName.Get("BranchPoint"))
                    |> Seq.length,
                    Is.EqualTo 2
                )

            printfn "Regression test issue 29 ------------------------------------------------"

            let proj =
                XDocument.Load "./RegressionTesting/issue29/issue29.xml"

            let pack =
                proj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            proj.Save "./RegressionTesting/issue29/issue29.csproj"
            let p29 = { p0 with AssemblyFilter = [ "NUnit" ] }
            let pp29 = AltCover.PrepareOptions.Primitive p29

            DotNet.test
                (fun to' ->
                    (to'
                        .WithCommon(
                            withWorkingDirectoryVM "RegressionTesting/issue29"
                        )
                         .WithAltCoverOptions
                         pp29
                         cc0
                         ForceTrueFast)
                    |> testWithCLIArguments)
                ""

            printfn "Regression test issue 37 ------------------------------------------------"

            let proj =
                XDocument.Load "./RegressionTesting/issue37/issue37.xml"

            let pack =
                proj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            proj.Save "./RegressionTesting/issue37/issue37.csproj"

            let p4 = { p0 with AssemblyFilter = [ "NUnit" ] }
            let pp4 = AltCover.PrepareOptions.Primitive p4

            DotNet.test
                (fun to' ->
                    { ((to'.WithCommon(withWorkingDirectoryVM "RegressionTesting/issue37"))
                          .WithAltCoverOptions
                           pp4
                           cc0
                           ForceTrue) with
                          Configuration = DotNet.BuildConfiguration.Release }
                    |> testWithCLIArguments)
                ""

            let cover37 =
                XDocument.Load "./RegressionTesting/issue37/coverage.xml"

            Assert.That(
                cover37.Descendants(XName.Get("BranchPoint"))
                |> Seq.length,
                Is.EqualTo 2
            )

        // printfn "Regression test issue 94 ------------------------------------------------"
        // let proj = XDocument.Load "./Samples/Sample22/Sample22.xml"
        // let pack = proj.Descendants(XName.Get("PackageReference")) |> Seq.head
        // let inject =
        //   XElement
        //     (XName.Get "PackageReference", XAttribute(XName.Get "Include", "altcover"),
        //      XAttribute(XName.Get "Version", Version.Value))
        // pack.AddBeforeSelf inject
        // proj.Save "./Samples/Sample22/Sample22.fsproj"

        // let p4 = { p0 with AssemblyFilter = [ "NUnit" ] }
        // let pp4 = AltCover.PrepareOptions.Primitive p4
        // DotNet.test (fun to' ->
        //   { ((to'.WithCommon(withWorkingDirectoryVM "Samples/Sample22")).WithAltCoverOptions
        //       pp4 cc0 ForceTrue) with Configuration = DotNet.BuildConfiguration.Release }
        //   |> testWithCLIArguments) ""

        finally
            let folder =
                (nugetCache @@ "altcover") @@ Version.Value

            Shell.mkdir folder
            Actions.CleanDir folder)

_Target
    "Issue20"
    (fun _ -> // plus added verbosity testing
        try
            let config =
                XDocument.Load "./Build/NuGet.config.dotnettest"

            let repo =
                config.Descendants(XName.Get("add")) |> Seq.head

            repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
            config.Save "./RegressionTesting/issue20/NuGet.config"

            let csproj =
                XDocument.Load "./RegressionTesting/issue20/xunit-tests/xunit-tests.xml"

            let pack =
                csproj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            csproj.Save "./RegressionTesting/issue20/xunit-tests/xunit-tests.csproj"

            DotNet.restore
                (fun o ->
                    let tmp =
                        o.WithCommon(withWorkingDirectoryVM "./RegressionTesting/issue20/classlib")

                    let mparams =
                        { tmp.MSBuildParams with
                              Properties = tmp.MSBuildParams.Properties }

                    { tmp with MSBuildParams = mparams })
                ""

            DotNet.restore
                (fun o ->
                    let tmp =
                        o.WithCommon(withWorkingDirectoryVM "./RegressionTesting/issue20/xunit-tests")

                    let mparams =
                        { tmp.MSBuildParams with
                              Properties = tmp.MSBuildParams.Properties }

                    { tmp with MSBuildParams = mparams })
                ""

            // would like to assert "succeeds with warnings"
            let p0 =
                { Primitive.PrepareOptions.Create() with
                      AssemblyFilter = [| "xunit" |] }

            let pp0 = AltCover.PrepareOptions.Primitive p0
            let c0 = Primitive.CollectOptions.Create()
            let cc0 = AltCover.CollectOptions.Primitive c0

            DotNet.test
                (fun to' ->
                    ({ to'.WithCommon(withWorkingDirectoryVM "./RegressionTesting/issue20/xunit-tests") with
                           Configuration = DotNet.BuildConfiguration.Debug
                           NoBuild = false })
                        .WithAltCoverOptions
                        pp0
                        cc0
                        ForceTrue
                    |> testWithCLIArguments)
                ""

            //let shared =
            //  if Environment.isWindows then
            //    [ "%ProgramFiles%/dotnet/shared/Microsoft.AspNetCore.App/2.1.5/Microsoft.AspNetCore.Cryptography.KeyDerivation.dll" ]
            //  else
            //    [ "/usr/share/dotnet/shared/Microsoft.AspNetCore.App/2.1.5/Microsoft.AspNetCore.Cryptography.KeyDerivation.dll" ]
            //Path.getFullName "./RegressionTesting/issue20/xunit-tests/bin" |> Shell.cleanDir
            //// would like to assert "no warnings"
            //let p1 = { p0 with Dependencies = shared }
            //DotNet.test
            //  (fun to' ->
            //  { to'.WithCommon(fun c ->
            //      { c with WorkingDirectory =
            //                 Path.getFullName"./RegressionTesting/issue20/xunit-tests"
            //               Verbosity = SomeDotNet.Verbosity.Minimal }).WithAltCoverOptions p1 c0 ForceTrue with Configuration =
            //                                                                                                 DotNet.BuildConfiguration.Debug
            //                                                                                               NoBuild =
            //                                                                                                 false
            //                                                                                               MSBuildParams =
            //                                                                                                 cliArguments })
            //  ""

            printfn "**************** And now with silence..."

            let p1 =
                { p0 with
                      Verbosity = System.Diagnostics.TraceLevel.Error }

            let pp1 = AltCover.PrepareOptions.Primitive p1

            DotNet.test
                (fun to' ->
                    ({ to'.WithCommon(withWorkingDirectoryVM "./RegressionTesting/issue20/xunit-tests") with
                           Configuration = DotNet.BuildConfiguration.Debug
                           NoBuild = false })
                        .WithAltCoverOptions
                        pp1
                        cc0
                        ForceTrue
                    |> testWithCLIArguments)
                ""

        finally
            let folder =
                (nugetCache @@ "altcover") @@ Version.Value

            Shell.mkdir folder
            Actions.CleanDir folder)

_Target
    "Issue23"
    (fun _ ->
        try
            Directory.ensure "./_Issue23"
            Shell.cleanDir ("./_Issue23")

            let config =
                XDocument.Load "./Build/NuGet.config.dotnettest"

            let repo =
                config.Descendants(XName.Get("add")) |> Seq.head

            repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
            config.Save "./_Issue23/NuGet.config"

            let csproj =
                XDocument.Load "./Samples/Sample9/sample9.csproj"

            let pack =
                csproj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            csproj.Save "./_Issue23/sample9.csproj"
            Shell.copy "./_Issue23" (!! "./Samples/Sample9/*.cs")
            Shell.copy "./_Issue23" (!! "./Samples/Sample9/*.json")

            DotNet.restore
                (fun o ->
                    let tmp =
                        o.WithCommon(withWorkingDirectoryVM "_Issue23")

                    let mparams =
                        { tmp.MSBuildParams with
                              Properties = tmp.MSBuildParams.Properties }

                    { tmp with MSBuildParams = mparams })
                ""

            let p0 =
                { Primitive.PrepareOptions.Create() with
                      AssemblyFilter = [| "xunit" |] }

            let pp0 = AltCover.PrepareOptions.Primitive p0
            let c0 = Primitive.CollectOptions.Create()
            let cc0 = AltCover.CollectOptions.Primitive c0

            DotNet.test
                (fun p ->
                    (({ p.WithCommon(withWorkingDirectoryVM "_Issue23") with
                            Configuration = DotNet.BuildConfiguration.Debug
                            NoBuild = false })
                        .WithAltCoverOptions
                         pp0
                         cc0
                         ForceTrue)
                        .WithAltCoverImportModule()
                        .WithAltCoverGetVersion()
                    |> testWithCLIArguments)
                ""
        finally
            let folder =
                (nugetCache @@ "altcover") @@ Version.Value

            Shell.mkdir folder
            Actions.CleanDir folder)

_Target
    "Issue67"
    (fun _ ->
        try
            Directory.ensure "./_Issue67" // escaping the | in a regex by doubling
            Shell.cleanDir ("./_Issue67")

            let config =
                XDocument.Load "./Build/NuGet.config.dotnettest"

            let repo =
                config.Descendants(XName.Get("add")) |> Seq.head

            repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
            config.Save "./_Issue67/NuGet.config"

            let csproj =
                XDocument.Load "./Samples/Sample9/sample9.csproj"

            let target =
                csproj.Descendants(XName.Get("TargetFramework"))
                |> Seq.head

            target.SetValue "netcoreapp2.1"

            let pack =
                csproj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            csproj.Save "./_Issue67/sample9.csproj"
            Shell.copy "./_Issue67" (!! "./Samples/Sample9/*.cs")
            Shell.copy "./_Issue67" (!! "./Samples/Sample9/*.json")

            DotNet.restore
                (fun o ->
                    let tmp =
                        o.WithCommon(withWorkingDirectoryVM "_Issue67")

                    let mparams =
                        { tmp.MSBuildParams with
                              Properties = tmp.MSBuildParams.Properties }

                    { tmp with MSBuildParams = mparams })
                ""

            let p0 =
                { Primitive.PrepareOptions.Create() with
                      AssemblyExcludeFilter = [| "?(sample9||xunit.runner.reporters.netcoreapp10)" |] }

            let pp0 = AltCover.PrepareOptions.Primitive p0
            let c0 = Primitive.CollectOptions.Create()
            let cc0 = AltCover.CollectOptions.Primitive c0

            DotNet.test
                (fun p ->
                    (({ p.WithCommon(withWorkingDirectoryVM "_Issue67") with
                            Configuration = DotNet.BuildConfiguration.Debug
                            NoBuild = false })
                        .WithAltCoverOptions
                         pp0
                         cc0
                         ForceTrue)
                        .WithAltCoverImportModule()
                        .WithAltCoverGetVersion()
                    |> testWithCLIArguments)
                ""

            let cover = XDocument.Load "./_Issue67/coverage.xml"

            let passed =
                cover.Descendants(XName.Get("Module"))
                |> Seq.filter (fun x -> x.Attribute(XName.Get("skippedDueTo")) |> isNull)
                |> Seq.length

            Assert.That(passed, Is.EqualTo 2)
        finally
            let folder =
                (nugetCache @@ "altcover") @@ Version.Value

            Shell.mkdir folder
            Actions.CleanDir folder)

_Target
    "Issue72"
    (fun _ -> // Confusing switch case coverage @ https://github.com/SteveGilham/altcover/issues/72
        try
            Directory.ensure "./Samples/Sample16/Test/_Issue72"
            Shell.cleanDir ("./Samples/Sample16/Test/_Issue72")
            Directory.ensure "./Samples/Sample16/Test/_Issue72b"
            Shell.cleanDir ("./Samples/Sample16/Test/_Issue72b")

            let config =
                XDocument.Load "./Build/NuGet.config.dotnettest"

            let repo =
                config.Descendants(XName.Get("add")) |> Seq.head

            repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging")
            config.Save "./Samples/Sample16/Test/_Issue72/NuGet.config"
            config.Save "./Samples/Sample16/Test/_Issue72b/NuGet.config"

            Shell.copy "./Samples/Sample16/Test/_Issue72" (!! "./Samples/Sample16/Test/Test/*.cs")
            Shell.copy "./Samples/Sample16/Test/_Issue72" (!! "./Samples/Sample16/Test/Test/*.json")
            Shell.copy "./Samples/Sample16/Test/_Issue72b" (!! "./Samples/Sample16/Test/Test/*.cs")
            Shell.copy "./Samples/Sample16/Test/_Issue72b" (!! "./Samples/Sample16/Test/Test/*.json")

            let csproj =
                XDocument.Load "./Samples/Sample16/Test/Test/Test.csproj"

            let pack =
                csproj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            csproj.Save "./Samples/Sample16/Test/_Issue72/Test.csproj"
            csproj.Save "./Samples/Sample16/Test/_Issue72b/Test2.csproj"

            let p0 =
                { Primitive.PrepareOptions.Create() with
                      LocalSource = true
                      VisibleBranches = false
                      TypeFilter = [ "UnitTest" ]
                      Report = "./original.$(ProjectName).xml" }

            let pp0 = AltCover.PrepareOptions.Primitive p0
            let c0 = Primitive.CollectOptions.Create()
            let cc0 = AltCover.CollectOptions.Primitive c0

            DotNet.test
                (fun p ->
                    (({ p.WithCommon(withWorkingDirectoryVM "./Samples/Sample16/Test/_Issue72") with
                            Configuration = DotNet.BuildConfiguration.Debug
                            NoBuild = false })
                        .WithAltCoverOptions
                         pp0
                         cc0
                         ForceTrue)
                        .WithAltCoverImportModule()
                        .WithAltCoverGetVersion()
                    |> testWithCLIArguments)
                ""

            do
                use coverageFile =
                    new FileStream(
                        "./Samples/Sample16/Test/_Issue72/original.Test.xml",
                        FileMode.Open,
                        FileAccess.Read,
                        FileShare.None,
                        4096,
                        FileOptions.SequentialScan
                    )

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                let found =
                    coverageDocument.Descendants(XName.Get("BranchPoint"))
                    |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                    |> Seq.toList

                test
                    <@ (found, "first") = ([ "1"
                                             "4"
                                             "3"
                                             "1"
                                             "2"
                                             "1"
                                             "1"
                                             "1"
                                             "5"
                                             "5" ],
                                           "first") @>
            // [ "1"; "4"; "4"; "0"; "3"; "1"; "2"; "1"; "1"; "1"; "5"; "5" ] @>
            //  Assert.That
            //    (found,
            //     Is.EquivalentTo [ "1"; "4"; "4"; "0"; "3"; "1"; "2"; "1"; "1"; "1"; "5"; "5" ],
            //     sprintf "original: %A" found)

            let p1 =
                { Primitive.PrepareOptions.Create() with
                      LocalSource = true
                      VisibleBranches = true
                      TypeFilter = [ "UnitTest" ]
                      Report = "./combined.$(ProjectName).xml" }

            let pp1 = AltCover.PrepareOptions.Primitive p1
            let c0 = Primitive.CollectOptions.Create()
            let cc0 = AltCover.CollectOptions.Primitive c0

            DotNet.test
                (fun p ->
                    (({ p.WithCommon(withWorkingDirectoryVM "./Samples/Sample16/Test/_Issue72") with
                            Configuration = DotNet.BuildConfiguration.Debug
                            NoBuild = false })
                        .WithAltCoverOptions
                         pp1
                         cc0
                         ForceTrue)
                        .WithAltCoverImportModule()
                        .WithAltCoverGetVersion()
                    |> testWithCLIArguments)
                ""

            do
                use coverageFile =
                    new FileStream(
                        "./Samples/Sample16/Test/_Issue72/combined.Test.xml",
                        FileMode.Open,
                        FileAccess.Read,
                        FileShare.None,
                        4096,
                        FileOptions.SequentialScan
                    )

                let coverageDocument =
                    XDocument.Load(XmlReader.Create(coverageFile))

                let found =
                    coverageDocument.Descendants(XName.Get("BranchPoint"))
                    |> Seq.map (fun x -> x.Attribute(XName.Get("vc")).Value)
                    |> Seq.toList

                test
                    <@ (found, "second") = ([ "1"
                                              "4"
                                              "1"
                                              "1"
                                              "1"
                                              "1"
                                              "5"
                                              "5" ],
                                            "second") @>
            //  Assert.That
            //    (found, Is.EquivalentTo [ "1"; "4"; "1"; "1"; "1"; "1"; "5"; "5" ],
            //     sprintf "combined: %A" found)

            // Issue 98 optest
            printfn "----------------------------- issue 98  ----------------------------------------"
            Shell.cleanDir ("./Samples/Sample16/Test/_Intermediate")

            let psln =
                AltCover.PrepareOptions.Primitive
                    { p0 with
                          Report = "$(SolutionDir)/_Reports/solution.$(ProjectName).xml" }

            DotNet.test
                (fun p ->
                    (({ p.WithCommon(withWorkingDirectoryVM "./Samples/Sample16/Test") with
                            Configuration = DotNet.BuildConfiguration.Debug
                            NoBuild = false })
                        .WithAltCoverOptions
                         psln
                         cc0
                         ForceTrue)
                        .WithAltCoverImportModule()
                        .WithAltCoverGetVersion()
                    |> testWithCLIArguments)
                "Issue72.sln"

            test <@ File.Exists("./Samples/Sample16/Test/_Reports/solution.Test.xml") @>
            test <@ File.Exists("./Samples/Sample16/Test/_Reports/solution.Test2.xml") @>

        finally
            let folder =
                (nugetCache @@ "altcover") @@ Version.Value

            Shell.mkdir folder
            Actions.CleanDir folder)

_Target
    "DotnetGlobalIntegration"
    (fun _ ->
        let working = Path.getFullName "./_DotnetGlobalTest"
        let mutable set = false

        try
            Directory.ensure working
            Shell.cleanDir working

            let fsproj =
                XDocument.Load "./Samples/Sample4/Sample4.fsproj"

            let targets =
                fsproj.Descendants(XName.Get("TargetFrameworks"))
                |> Seq.head

            targets.SetValue "netcoreapp2.1"
            targets.AddAfterSelf(XElement(XName.Get "DocumentationFile"))

            fsproj.Descendants(XName.Get("HintPath"))
            |> Seq.iter
                (fun hint ->
                    "ThirdParty/Unquote.dll"
                    |> Path.getFullName
                    |> hint.SetValue)

            fsproj.Save "./_DotnetGlobalTest/_DotnetGlobalTest.fsproj"
            Shell.copy "./_DotnetGlobalTest" (!! "./Samples/Sample4/*.fs")
            Shell.copy "./_DotnetGlobalTest" (!! "./Samples/Sample4/*.json")
            Shell.copyDir "./_DotnetGlobalTest/Data" "./Samples/Sample4/Data" File.Exists

            Actions.RunDotnet
                (fun o' ->
                    { dotnetOptions o' with
                          WorkingDirectory = working })
                "tool"
                ("install -g altcover.global --add-source "
                 + (Path.getFullName "./_Packaging.global")
                 + " --version "
                 + Version.Value)
                "Installed"

            Actions.RunDotnet
                (fun o' ->
                    { dotnetOptions o' with
                          WorkingDirectory = working })
                "tool"
                ("list -g ")
                "Checked"

            set <- true

            ""
            |> DotNet.build
                (fun p ->
                    { p with
                          Configuration = DotNet.BuildConfiguration.Debug
                          Common =
                              { dotnetOptions p.Common with
                                    WorkingDirectory = working }
                          MSBuildParams = cliArguments })

            let x =
                Path.getFullName "./_Reports/DotnetGlobalIntegration.xml"

            let o =
                Path.getFullName "./_Binaries/_DotnetGlobalTest/Debug+AnyCPU/netcoreapp2.1"

            [ AltCoverCommand.ArgumentType.ImportModule
              AltCoverCommand.ArgumentType.GetVersion ]
            |> List.iter (
                AltCoverCommand.Options.Create
                >> AltCoverCommand.run
            )

            let before = Actions.ticksNow ()

            Actions.Run("altcover", ".", [ "TargetsPath" ]) "altcover target"

            let prep =
                AltCover.PrepareOptions.Primitive(
                    { Primitive.PrepareOptions.Create() with
                          Report = x
                          InputDirectories = [ o ]
                          CallContext = [ "0"; "[Fact]" ]
                          AssemblyFilter = [| "xunit" |]
                          InPlace = true
                          Save = false }
                )
                |> AltCoverCommand.Prepare

            { AltCoverCommand.Options.Create prep with
                  WorkingDirectory = working }
            |> AltCoverCommand.run

            Actions.CheckSample4Content x

            printfn "Execute the instrumented tests"

            let (dotnetexe, args) =
                defaultDotNetTestCommandLine (Some "netcoreapp2.1") String.Empty

            let collect =
                AltCover.CollectOptions.Primitive
                    { Primitive.CollectOptions.Create() with
                          Executable = dotnetexe
                          RecorderDirectory = o
                          CommandLine = args }
                |> AltCoverCommand.Collect

            { AltCoverCommand.Options.Create collect with
                  WorkingDirectory = working }
            |> AltCoverCommand.run

            Actions.CheckSample4Visits before x

            let command =
                """$ImportModule = (altcover ImportModule | Out-String).Trim().Split()[1].Trim(@([char]34)); Import-Module $ImportModule; ConvertTo-BarChart -?"""

            CreateProcess.fromRawCommand pwsh [ "-NoProfile"; "-Command"; command ]
            |> CreateProcess.withWorkingDirectory working
            |> Proc.run
            |> (Actions.AssertResult "pwsh")

        finally
            if set then
                Actions.RunDotnet
                    (fun o' ->
                        { dotnetOptions o' with
                              WorkingDirectory = working })
                    "tool"
                    ("uninstall -g altcover.global")
                    "uninstalled"

            let folder =
                (nugetCache @@ "altcover.global") @@ Version.Value

            Shell.mkdir folder
            Actions.CleanDir folder)

_Target
    "Issue114"
    (fun _ ->
        try
            Directory.ensure "./_Issue114"
            Shell.cleanDir ("./_Issue114")

            let config =
                XDocument.Load "./Build/NuGet.config.dotnettest"

            let repo =
                config.Descendants(XName.Get("add")) |> Seq.head

            repo.SetAttributeValue(XName.Get "value", Path.getFullName "./_Packaging.api")
            config.Save "./_Issue114/NuGet.config"

            let csproj =
                XDocument.Load "./Samples/Sample26/Sample26.fsproj"

            let pack =
                csproj.Descendants(XName.Get("PackageReference"))
                |> Seq.head

            let inject =
                XElement(
                    XName.Get "PackageReference",
                    XAttribute(XName.Get "Include", "altcover.api"),
                    XAttribute(XName.Get "Version", Version.Value)
                )

            pack.AddBeforeSelf inject
            csproj.Save "./_Issue114/Sample26.fsproj"
            Shell.copy "./_Issue114" (!! "./Samples/Sample26/*.fs")

            DotNet.restore
                (fun o ->
                    let tmp =
                        o.WithCommon(withWorkingDirectoryVM "_Issue114")

                    let mparams =
                        { tmp.MSBuildParams with
                              Properties = tmp.MSBuildParams.Properties }

                    { tmp with MSBuildParams = mparams })
                ""

            let p0 =
                { Primitive.PrepareOptions.Create() with
                      AssemblyFilter =
                          [| "nunit"
                             "Adapter"
                             "FSharp"
                             "AltCover" |] }

            let pp0 = AltCover.PrepareOptions.Primitive p0
            let c0 = Primitive.CollectOptions.Create()
            let cc0 = AltCover.CollectOptions.Primitive c0

            DotNet.test
                (fun p ->
                    (({ p.WithCommon(withWorkingDirectoryVM "_Issue114") with
                            Configuration = DotNet.BuildConfiguration.Debug
                            NoBuild = false })
                        .WithAltCoverOptions
                         pp0
                         cc0
                         ForceTrue)
                        .WithAltCoverImportModule()
                        .WithAltCoverGetVersion()
                    |> testWithCLIArguments)
                ""
        finally
            let folder =
                (nugetCache @@ "altcover.api") @@ Version.Value

            Shell.mkdir folder
            Actions.CleanDir folder)

// AOB

_Target
    "MakeDocumentation"
    (fun _ ->
        let branch = Information.getBranchName (".")
        Assert.That(branch, Is.EqualTo("master").Or.StartWith("develop/docs/"), branch)

        CreateProcess.fromRawCommand
            "powershell.exe"
            [ "-NoProfile"
              "./Build/prepareDocumentation.ps1" ]
        |> CreateProcess.withWorkingDirectory "."
        |> Proc.run
        |> (Actions.AssertResult "powershell"))

_Target
    "BulkReport"
    (fun _ ->
        printfn "Overall coverage reporting"

        // coverageSummary ()

        // Cobertura .xsd windows-1252 support
        Encoding.RegisterProvider(CodePagesEncodingProvider.Instance)

        let schemaOf x =
            let result = XmlSchemaSet()
            use stream = File.OpenRead x
            use reader = XmlReader.Create(stream)
            result.Add(String.Empty, reader) |> ignore
            result

        let coberturaStrict =
            schemaOf "./AltCover.Tests/coverage-04.xsd"

        let cobertura34 =
            schemaOf "./AltCover.Toolkit/xsd/Cobertura.xsd"

        let ncover =
            schemaOf "./AltCover.Toolkit/xsd/NCover.xsd"

        let ncoverEmbedded =
            schemaOf "./AltCover.Toolkit/xsd/NCoverEmbedded.xsd"

        let opencover =
            schemaOf "./AltCover.Toolkit/xsd/OpenCover.xsd"

        let opencoverStrict =
            schemaOf "./AltCover.Toolkit/xsd/OpenCoverStrict.xsd"

        let packages = "packages" |> Path.getFullName

        let files =
            !!(@"./**/*.xml")
            |> Seq.filter
                (fun f ->
                    f.StartsWith(packages, StringComparison.Ordinal)
                    |> not)
            |> Seq.toList

        let xml =
            files |> List.map (fun x -> x, XDocument.Load x)

        let ncover2Files =
            xml
            |> List.filter
                (fun x ->
                    let root = (snd x).Root

                    root.Name.LocalName = "coverage"
                    && isNull <| root.Attribute(XName.Get "line-rate"))
            |> List.filter
                (fun x ->
                    try
                        (snd x).Validate(ncoverEmbedded, null)
                        false
                    with
                    | :? XmlSchemaValidationException -> true)
            |> List.map fst

        let expected =
            [ // 3 broken visit counts + 1 alien format
              "AltCover.Recorder.Tests/SimpleCoverage.xml"
              "AltCover.Tests/NCover122.xml"
              "__AltCover.Recorder.Tests/SimpleCoverage.xml"
              "Samples/Sample20/Reports/mprof-report.xml" ]
            |> List.map Path.getFullName
            |> List.filter File.Exists

        Assert.That(ncover2Files, Is.EquivalentTo expected, "ncover2Files")

        let ncoverFiles =
            xml
            |> List.filter
                (fun x ->
                    let root = (snd x).Root

                    root.Name.LocalName = "coverage"
                    && isNull <| root.Attribute(XName.Get "line-rate"))
            |> List.filter
                (fun x ->
                    try
                        (snd x).Validate(ncover, null)
                        false
                    with
                    | :? XmlSchemaValidationException -> true)
            |> List.map fst

        let expectedStrict =
            [ expected // add embedded source cases
              !!(@"./_Binaries/**/FlushLeavesExpectedTracesWhenDiverted.xml")
              |> Seq.toList
              [ "_Packaging/HandRolledMonoNCover.xml"
                "AltCover.Tests/HandRolledToNCover.xml"
                "AltCover.Tests/NCoverWithEmbeds.xml"
                "AltCover.Tests/NCoverWithPartials.xml" ]
              |> List.map Path.getFullName ]
            |> List.concat
            |> List.filter File.Exists

        Assert.That(ncoverFiles, Is.EquivalentTo expectedStrict, "ncoverFiles")

        let coberturaFiles =
            xml
            |> List.filter
                (fun x ->
                    let root = (snd x).Root

                    root.Name.LocalName = "coverage"
                    && not (isNull <| root.Attribute(XName.Get "line-rate")))
            |> List.filter
                (fun x ->
                    try
                        (snd x).Validate(cobertura34, null)
                        false
                    with
                    | :? XmlSchemaValidationException -> true)
            |> List.map fst

        Assert.That(coberturaFiles, Is.EquivalentTo [], "coberturaFiles")

        let cobertura2Files =
            xml
            |> List.filter
                (fun x ->
                    let root = (snd x).Root

                    root.Name.LocalName = "coverage"
                    && not (isNull <| root.Attribute(XName.Get "line-rate")))
            |> List.filter
                (fun x ->
                    try
                        (snd x).Validate(coberturaStrict, null)
                        false
                    with
                    | :? XmlSchemaValidationException -> true)
            |> List.map fst

        let c2expect =
            [ "Samples/Sample20/Reports/Cobertura_altcover.xml"
              "Samples/Sample20/Reports/Cobertura_coverlet.xml" ]
            |> List.map Path.getFullName

        Assert.That(cobertura2Files, Is.EquivalentTo c2expect, "cobertura2Files")

        let opencoverFiles =
            xml
            |> List.filter
                (fun x ->
                    let root = (snd x).Root
                    root.Name.LocalName = "CoverageSession")
            |> List.filter
                (fun x ->
                    try
                        (snd x).Validate(opencover, null)
                        false
                    with
                    | :? XmlSchemaValidationException -> true)
            |> List.map fst

        let o1expect =
            [ "AltCover.Recorder.Tests/Sample1WithModifiedOpenCover.xml" // vc broken
              "AltCover.Tests/issue122.xml" // ditto
              "AltCover.Tests/Sample1WithOpenCover.xml" // ditto
              "__AltCover.Recorder.Tests/Sample1WithModifiedOpenCover.xml" // vc broken
              "Samples/Sample20/Reports/OpenCover_coverlet.xml" ] // coverlet spelling error upsid "The required attribute 'uspid' is missing."
            |> List.map Path.getFullName
            |> List.filter File.Exists

        Assert.That(opencoverFiles, Is.EquivalentTo o1expect, "opencoverFiles")

        let opencover2Files =
            xml
            |> List.filter
                (fun x ->
                    let root = (snd x).Root
                    root.Name.LocalName = "CoverageSession")
            |> List.filter
                (fun x ->
                    try
                        (snd x).Validate(opencoverStrict, null)
                        false
                    with
                    | :? XmlSchemaValidationException -> true)
            |> List.map fst

        let o2expect =
            [ // embeds
              "__AltCover.Api.Tests/OpenCover.xml"
              "AltCover.Api.Tests/OpenCover.xml"
              "_DotnetTestBranchCover/coverage.xml"
              "_DotnetTestBranchCoverInPlace/coverage.xml"
              "_DotnetTestLineCover/coverage.xml"
              "_DotnetTestLineCoverInPlace/coverage.xml"
              "_Issue23/coverage.xml"
              "_Issue67/coverage.xml"
              "AltCover.Tests/HandRolledMonoCoverage.xml"
              "AltCover.Tests/OpenCoverWithEmbeds.xml"
              "AltCover.Tests/OpenCoverWithPartials.xml"
              "AltCover.Tests/Sample4FullTracking.xml"
              // coverlet
              "AltCover.Api.Tests/OpenCoverForPester.coverlet.xml"
              "AltCover.Tests/OpenCoverForPester.coverlet.expected.xml"
              "__AltCover.Api.Tests/OpenCoverForPester.coverlet.xml"
              "AltCover.Tests/Sample21.coverage.opencover.xml"
              "AltCover.Tests/Sample4.coverlet.xml" ]

        let o3expect = // embeds
            !!(@"./**/JsonWithPartials*Xml.xml") |> Seq.toList

        let o4expect = // coverlet
            !!(@"./_Reports/**/*.coverlet.xml") |> Seq.toList

        let o5expect = // coverlet
            !!(@"./**/coverage.opencover.xml") |> Seq.toList

        let oexpect =
            [ o1expect
              o2expect
              o3expect
              o4expect
              o5expect ]
            |> List.concat
            |> List.map Path.getFullName
            |> List.filter File.Exists

        Assert.That(opencover2Files, Is.EquivalentTo oexpect, "opencover2Files")

        // let noncoverFiles =
        //     xml
        //     |> List.filter (fun x -> let root = (snd x).Root
        //                              root.Name.LocalName <> "CoverageSession" &&
        //                              root.Name.LocalName <> "coverage")

        //     |> List.map fst
        // Assert.That(noncoverFiles, Is.EquivalentTo [])

        let issue71 = !!(@"./**/*.exn") |> Seq.toList

        match issue71 with
        | [] -> ()
        | _ ->
            issue71 |> Seq.iter (printfn "%s")
            Assert.Fail("Issue #71 experienced"))

_Target "All" ignore

_Target
    "CppInline"
    (fun _ ->
        if Environment.isWindows then
            Directory.ensure "./_Reports/CppInline"
            msbuildDebug None "./Samples/Sample29/SimpleMix.sln"

            OpenCover.run
                (fun p ->
                    { p with
                          WorkingDir = "."
                          ExePath = openCoverConsole
                          TestRunnerExePath = "./Samples/Sample29/Debug/SimpleMix.exe"
                          MergeByHash = true
                          ReturnTargetCode = Fake.DotNet.Testing.OpenCover.ReturnTargetCodeType.Yes
                          Register = OpenCover.RegisterType.Path64
                          Output = Path.getFullName "_Reports/CppInlineWithOpenCover.xml"
                          TimeOut = TimeSpan(0, 10, 0) })
                String.Empty

            ReportGenerator.generateReports
                (fun p ->
                    { p with
                          ToolType = ToolType.CreateLocalTool()
                          ReportTypes =
                              [ ReportGenerator.ReportType.Html
                                ReportGenerator.ReportType.XmlSummary ]
                          TargetDir = "_Reports/CppInline" })
                [ "_Reports/CppInlineWithOpenCover.xml" ])

let resetColours _ =
    Console.ForegroundColor <- consoleBefore |> fst
    Console.BackgroundColor <- consoleBefore |> snd

Target.description "ResetConsoleColours"
Target.createFinal "ResetConsoleColours" resetColours
Target.activateFinal "ResetConsoleColours"

// Dependencies

"Clean" ==> "SetVersion" ==> "Preparation"

"Preparation" ==> "BuildDebug"

"BuildDebug" ==> "BuildRelease" ==> "Compilation"

"BuildRelease"
==> "BuildMonoSamples"
==> "Compilation"

// My machine only
"BuildMonoSamples" ==> "BuildSample31"

"BuildDebug" ==> "Lint" ==> "Analysis"

"Compilation" ?=> "Analysis"

"BuildDebug" ==> "FxCop"
=?> ("Analysis", Environment.isWindows && fxcop |> Option.isSome) // not supported

"BuildDebug" ==> "Gendarme" ==> "Analysis"

"Compilation" ?=> "UnitTest"

// deadweight/duplicate/restricted unit tests

"Compilation" ==> "JustUnitTest"
// ==> "UnitTest" // deadweight

"Compilation"
==> "BuildForUnitTestDotNet"
==> "UnitTestDotNet"
// ==> "UnitTest" // deadweight

"Compilation" ==> "UnitTestWithOpenCover"
// =?> ("UnitTest", Environment.isWindows)  // OpenCover Mono support; deadweight

"Compilation" ==> "UnitTestWithAltCover"
// ==> "UnitTest" // deadweight

"Compilation" ==> "UnitTestWithAltCoverCore"
// ==> "UnitTest" // deadweight

// meaningful coverage tests

"Compilation"
==> "UnitTestWithAltCoverRunner"
==> "UnitTest" // no special coverage

"Packaging"
==> "UnitTestWithAltCoverCoreRunner"
==> "UnitTest" // Monitor & pwsh coverage

"Compilation"
==> "BuildForCoverlet"
==> "UnitTestDotNetWithCoverlet"
==> "UnitTest" // Third party check

"JustUnitTest" ==> "UncoveredUnitTest"

"UnitTestDotNet" ==> "UncoveredUnitTest"

"Compilation" ?=> "OperationalTest"

"Compilation"
==> "FSharpTypes"
==> "OperationalTest"

"Compilation"
==> "FSharpTests"
==> "OperationalTest"

"Compilation"
==> "AsyncAwaitTests"
==> "OperationalTest"

"Compilation"
==> "FSAsyncTests"
==> "OperationalTest"

"Compilation"
==> "FSharpTypesDotNetRunner"
==> "OperationalTest"

"Compilation"
==> "FSharpTypesDotNetCollecter"
==> "OperationalTest"

"Compilation"
==> "BasicCSharp"
==> "OperationalTest"

"Compilation" ==> "BasicCSharpMono"
=?> ("OperationalTest", Environment.isWindows) // redundant on mono

"Compilation" ==> "BasicCSharpUnderMono"
=?> ("OperationalTest", Option.isSome monoOnWindows)

"Compilation" ==> "BasicCSharpMonoUnderMono"
=?> ("OperationalTest", Option.isSome monoOnWindows)

"Compilation"
==> "CSharpMonoWithDotNet"
==> "OperationalTest"

"Compilation"
==> "CSharpDotNetWithDotNet"
==> "OperationalTest"

"Compilation"
==> "CSharpDotNetWithFramework"
==> "OperationalTest"

"Compilation"
==> "RecordResumeTest"
==> "OperationalTest" // AltCover.exe conditional

"Compilation"
==> "RecordResumeTrackingTest"
==> "OperationalTest" // AltCover.exe conditional

"Compilation"
==> "RecordResumeTestDotNet"
==> "OperationalTest"

"Compilation" ?=> "Packaging"

"Compilation"
==> "PrepareFrameworkBuild"
==> "Packaging"

"Compilation"
==> "PrepareDotNetBuild"
==> "Packaging"

"Compilation" ==> "PrepareReadMe" ==> "Packaging"

"Packaging" ==> "Unpack"

"Compilation" ?=> "Deployment"

"Unpack"
==> "Pester"
==> "UnitTestWithAltCoverCoreRunner"

"FSharpTests" ==> "Pester"

"FSharpTests" ==> "WindowsPowerShell"
=?> ("Pester", Environment.isWindows)

"Unpack" ==> "WindowsPowerShell"
=?> ("Deployment", Environment.isWindows)

"ReleaseXUnitFSharpTypesDotNetRunner"
=?> ("WindowsPowerShell", Environment.isWindows)

"OpenCoverForPester"
=?> ("WindowsPowerShell", Environment.isWindows)

"Unpack"
==> "ReleaseXUnitFSharpTypesDotNetRunner"
==> "Pester"
==> "Deployment"

"Unpack" ==> "OpenCoverForPester" ==> "Pester"

"Unpack" ==> "SimpleReleaseTest" ==> "Deployment"

"Unpack"
==> "SimpleZipReleaseTest"
==> "Deployment"

"Unpack"
==> "SimpleMonoReleaseTest"
==> "Deployment"

"Unpack"
==> "ReleaseMonoWithDotNet"
==> "Deployment"

"Unpack"
==> "ReleaseDotNetWithDotNet"
==> "Deployment"

"Unpack"
==> "ReleaseDotNetWithFramework"
==> "Deployment"

"Unpack"
==> "ReleaseFSharpTypesDotNetRunner"
==> "Deployment" // test is duplicated in the Pester testing

"Unpack" ==> "ReleaseFSharpTypesX86DotNetRunner"
=?> ("Deployment", Option.isSome dotnetPath86)

"Unpack"
==> "ReleaseXUnitFSharpTypesShowVisualized"
==> "Deployment"

"Unpack" ==> "MSBuildTest" ==> "Deployment"

"Unpack" ==> "ApiUse" ==> "Deployment"

"Unpack" ==> "Cake1Test" ==> "Deployment"

"Unpack"
==> "DotnetTestIntegration"
==> "Deployment"

"Unpack" ==> "Issue23"
=?> ("Deployment", Environment.isWindows)

"Unpack" ==> "Issue67" ==> "Deployment"

"Unpack" ==> "Issue72" ==> "Deployment"

"Unpack" ==> "Issue20" ==> "Deployment"

"Unpack" ==> "Issue114" ==> "Deployment"

"Unpack"
==> "DotnetGlobalIntegration"
==> "Deployment"

"Unpack"
==> "ReleaseXUnitFSharpTypesDotNetFullRunner"
==> "Deployment"

"Unpack" ==> "JsonReporting" ==> "Deployment"

"Analysis" ==> "All"

"UnitTest" ==> "BulkReport" ==> "All"

"OperationalTest" ==> "All"

"Deployment" ==> "BulkReport" ==> "All"

let defaultTarget () =
    resetColours ()
    "All"

Target.runOrDefault <| defaultTarget ()